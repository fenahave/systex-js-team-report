<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript 同步與非同步</title>
    <script src="../js/run_pprettify.js"></script>
    <link rel="stylesheet" href="../css/style.css" />
    <link rel="stylesheet" href="../css/pretty.css" />
    <style>
      #container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #header,
      main {
        width: 80%;
        max-width: 1200px;
      }
      #header {
        text-align: left;
      }
      main {
        margin-top: 20px;
      }
      #toc ul {
        list-style-type: disc;
        padding-left: 20px;
      }
      #toc li {
        margin: 5px 0;
      }
      #toc a {
        text-decoration: none;
        color: #1a73e8;
      }
      #toc a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="header">
        <header>
          <h1>JavaScript 同步與非同步</h1>
        </header>
        <nav id="toc" class="toc">
          <div id="toctitle">目錄</div>
          <ul class="sectlevel1">
            <li>
              <a href="#_同步與非同步概念">同步與非同步概念</a>
              <ul>
                <li><a href="#_同步是什麼">同步是什麼？</a></li>
                <li><a href="#_非同步是什麼">非同步是什麼？</a></li>
                <li>
                  <a href="#_為什麼Javascript可以非同步"
                    >為什麼 JavaScript 可以非同步？</a
                  >
                </li>
                <li><a href="#_為什麼需要非同步">為什麼需要非同步</a></li>
              </ul>
            </li>
            <li>
              <a href="#_ajax與數據請求">AJAX 與數據請求</a>
              <ul>
                <li><a href="#_什麼是_ajax">什麼是 AJAX?</a></li>
                <li><a href="#_xmlhttprequest">XMLHttpRequest</a></li>
                <li><a href="#_fetch">Fetch</a></li>
                <li>
                  <a href="#_fetch_xhr_comparison">XMLHttpRequest vs. Fetch</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#_promise與非同步處理">Promise 與非同步處理</a>
              <ul>
                <li>
                  <a href="#_promise">Promise</a>
                  <ul>
                    <li><a href="#_promise的狀態">Promise 的狀態</a></li>
                    <li><a href="#_基本結構">基本結構</a></li>
                    <li><a href="#_鏈式結構">鏈式結構</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#_promise_all">Promise.all()</a>
                  <ul>
                    <li><a href="#_promise_all_使用範例">使用範例</a></li>
                    <li>
                      <a href="#_promise_all的工作方式"
                        >Promise.all() 的工作方式</a
                      >
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </nav>
      </div>

      <main>
        <section id="_同步與非同步概念">
          <h2>同步與非同步概念</h2>
          <section id="_同步是什麼">
            <h3>同步是什麼？</h3>
            <p>「同步」常讓人困惑，實際上它代表一次只能做一件事情。</p>
            <p>
              JavaScript 是「單執行續 (Single-Thread)」語言，意思是它一次只能執行一個任務，事情會排隊依序完成。這是同步的概念。
            </p>
            <pre class="prettyprint">
// Synchronous code example
console.log("Start");

function syncTask() {
  console.log("Performing a synchronous task");
}

syncTask();

console.log("End");
            </pre>
          </section>

          <section id="_非同步是什麼">
            <h3>非同步是什麼？</h3>
            <p>
              非同步則是相反的，它允許同時進行多個任務，無需等待前一件事完成後再做下一件。
            </p>
            <pre class="prettyprint">
console.log("hello");
setTimeout(function() {
  console.log("End");
}, 1000);

for(let i = 0; i < 4; i++) {
    console.log(i);
}
            </pre>
          </section>

          <section id="_為什麼需要非同步">
            <h3>為什麼需要非同步？什麼時候會用到？</h3>
            <h4>Blocking</h4>
            <p>阻塞（blocking） 是指程式在執行某個操作時，必須等待該操作完成，才能繼續執行後續的程式碼。在阻塞過程中，程式的執行會暫停，等待某個資源或操作完成，這段時間內，其他操作無法進行。這通常發生在某些需要較長時間才能完成的操作上，比如以下：</p>
            <ul>
              <li><strong>向 API 發送請求：</strong>如果沒有非同步執行這些行為，那你呼叫了一支 API，在等待資料回傳的過程中，網頁什麼事都沒辦法執行，連渲染畫面都不行，user 只能等在那裡，那肯定是不行的。</li>
              <li><strong>setTimeout：</strong>又或者你曾經使用過 setTimeout 去處理要晚一點發生的事情，這個 setTimeout 會等待你所指定的時間，等到時間到了，再將需要發生的事件丟回 Javascript，讓 Javascript 知道說有這個事情排隊著要來觸發了。</li>
              <li><strong>document：</strong>使用 document.querySelector 去獲得你要操作的 DOM 其實也是瀏覽器提供的，是讓 Javascript 可以和瀏覽器溝通的方法。</li>
            </ul>
            <p><a href="./blocking-demo.html">Blocking Demo</a></p>

          </section>
          <section id="_為什麼Javascript可以非同步"></section>
            <h3>為什麼 JavaScript 可以非同步？</h3>
            <p>
              JavaScript 是單執行緒語言，但它可以與瀏覽器提供的 WebAPI
              (例如：document、XMLHttpRequest、setTimeout)
              進行溝通，達到非同步處理。
            </p>
            <p>
              這樣 JavaScript 引擎本身是同步的，而透過
              WebAPI，它可以同時處理多個任務 (Concurrency)。
            </p>
            <p><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">How does it work</a></p>
          </section>
        </section>

      <section>
        <section id="_ajax與數據請求">
          <h2>AJAX 與數據請求</h2>
          <section id="_什麼是_ajax">
            <h3>什麼是 AJAX?</h3>
            <p>
              AJAX（Asynchronous
              <a
                href="https://developer.mozilla.org/zh-TW/docs/Glossary/JavaScript"
                >JavaScript</a
              >
              And
              <a href="https://developer.mozilla.org/en-US/docs/Glossary/XML"
                >XML</a
              >，非同步 JavaScript 與 XML）是結合了
              <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/HTML"
                >HTML</a
              >、<a href="https://developer.mozilla.org/zh-TW/docs/Glossary/CSS"
                >CSS</a
              >、JavaScript、<a
                href="https://developer.mozilla.org/zh-TW/docs/Glossary/DOM"
                >DOM</a
              >、還有
              <code>XMLHttpRequest</code> 物件，以建立更複雜的網頁應用。AJAX
              允許網頁只更新所需的部分，而無需重新載入整個頁面。雖然名字中有
              XML，但它也可以用現今廣泛使用的 JSON 及其他資料類型（如 HTML, Form
              Data, Binary Data, Blob, ArrayBuffer）進行資料交換。
            </p>
          </section>

          <section id="_xmlhttprequest">
            <h3>XMLHttpRequest</h3>
            <p>
              XMLHttpRequest 是 JavaScript 中的物件，允許網頁向伺服器發送 HTTP
              或 HTTPS
              請求，並在不重新載入整個網頁的情況下接收回應資料。這項技術是實現
              AJAX 的重要組成部分，能讓網頁內容動態更新。雖然現在常用 fetch()
              技術，但 XMLHttpRequest 在某些較舊的項目中仍然被廣泛使用。
            </p>

            <h4>XMLHttpRequest 基本概念</h4>
            <h5>1. 建立 XMLHttpRequest 物件</h5>
            <pre class="prettyprint">let xhr = new XMLHttpRequest();</pre>
            <p>
              此時仍為同步語句，非同步操作尚未開始<br />
              物件創建：創建了一個新的XMLHttpRequest物件<br />
              記憶體分配：xhr物件被分配在記憶體的Heap中<br />
              初始狀態：此時xhr.readyState的值為0，表示UNSENT<br />
            </p>
            <p><strong>readyState 狀態值：</strong></p>
            <ul>
              <li>0: UNSENT – 請求尚未打開。</li>
              <li>1: OPENED – 請求已打開，但尚未發送。</li>
              <li>2: HEADERS_RECEIVED – 已收到伺服器回應標頭。</li>
              <li>3: LOADING – 請求正在處理，回應的資料正在接收。</li>
              <li>4: DONE – 請求已完成，回應可用。</li>
            </ul>
            <h5>2. 打開請求 (open)</h5>
            <pre class="prettyprint">
xhr.open('GET', 'https://api.example.com/data', true);</pre
            >
            <br />
            <p>
              該方法初始化了一個HTTP請求，只聽了請求方法與URL，第三個參數為true表示非同步<br />
              此時xhr.readyState的值變為1<br />
              調用 open() 方法僅僅是設定請求參數，還沒開始網路通訊<br />
            </p>
   
            <h5>3. 發送請求 (send)</h5>
            <pre class="prettyprint">xhr.send();</pre>
            <p>如果是 POST 請求，可以將資料以字串格式傳入 send() 中：</p>
            <pre class="prettyprint">
let data = JSON.stringify({ name: "Oscar", age: 24 });
xhr.send(data);</pre
            >
            <br />
            <p><strong>此時瀏覽器做了什麼？</strong></p>
            <p>
              一、準備發送請求<br />
              &emsp;1.檢查 XMLHttpRequest 物件的狀態<br />
              &emsp;&emsp;確認狀態為已初始化：確保已經調用了 open() 方法，readyState 為 1（OPENED）。<br />
              &emsp;&emsp;確認請求已設定：請求方法、URL、同步或非同步步標誌等已正確設置。<br />
              &emsp; 2.處理Request Headers<br />
              &emsp;&emsp;應用預設的Request Headers：如 Accept、User-Agent 等。<br />
              &emsp;&emsp;應用開發者設置的Request Headers：如果在調用 send() 之前使用 setRequestHeader() 設置了自定義的Request Headers，<br />
              &emsp;&emsp;這些Headers會在請求中被包含。<br />
              &emsp;3.Request Body<br />
              &emsp;&emsp;處理Request Body數據：如果請求方法為 POST、PUT 等，並且在 send() 方法中傳入了Request Body，瀏覽器會對數據進行適當的編碼<br />
              &emsp;&emsp;（如將 JavaScript 物件轉換為 JSON 字符串）。<br />
            </p>
            <p>
              二、發送網路請求<br />
              &emsp;1. 開始網路通訊<br />
              &emsp;&emsp;委派給Network Thread：瀏覽器將網路請求交給Network Thread處理，以避免阻塞Main Thread（JavaScript 執行環境）。<br />
              &emsp;&emsp;建立連接：如果與目標伺服器之間沒有現有的連接，瀏覽器會建立一個新的 TCP 連接，可能會進行 DNS 查詢、TLS 握手等。<br />
              &emsp;2. 發送 HTTP 請求<br />
              &emsp;&emsp;構建 HTTP 請求：將請求方法、URL、HTTP 版本、Request header和Request Body組合成完整的 HTTP 請求報文。<br />
              &emsp;&emsp;發送請求報文：通過網路將請求報文發送給目標伺服器。<br />

            </p>
            <p>
              三、處理請求過程中的事件<br />
              &emsp;1. 更新 readyState<br />
              &emsp;&emsp;readyState 變化：請求發送後，readyState 仍為 1。隨著請求的進展，readyState 會發生1~4的變化：<br />
              &emsp;2. 觸發事件處理器<br />
              &emsp;&emsp;onreadystatechange 事件：每當 readyState 發生變化時，瀏覽器會調用 onreadystatechange 回調函數。<br />
            </p>
            <p>
              四、接收Response <br />
              &emsp;1. 收到Response Header<br />
              &emsp;&emsp;狀態碼和狀態文本：瀏覽器接收到伺服器的Response Header，獲取 HTTP 狀態碼（如 200、404）和狀態文本（如 OK、Not Found）。<br />
              &emsp;&emsp;Response Header資訊：獲取伺服器返回的Response Header，如 Content-Type、Content-Length、Set-Cookie 等。<br />
              &emsp;2. 更新 readyState 為 2<br />
              &emsp;&emsp;觸發 onreadystatechange：readyState 變為 2，觸發 onreadystatechange 回調。<br />
              &emsp;3. 接收Response 體<br />
              &emsp;&emsp;數據流接收：瀏覽器開始接收Response 體數據，這個過程可能是漸進式的，特別是對於大型文件。<br />
              &emsp;&emsp;更新 readyState 為 3：<br />
              &emsp;&emsp;觸發 onreadystatechange：readyState 變為 3，表示正在接收Response 體，觸發 onreadystatechange 回調。<br />
              &emsp;&emsp;觸發 onprogress：在接收過程中，多次觸發 onprogress 事件，可用於更新下載進度。<br />
              &emsp;4. 接收完成<br />
              &emsp;&emsp;更新 readyState 為 4：<br />
              &emsp;&emsp;readyState 變為 4（DONE），表示Response 已完整接收。<br />
              &emsp;&emsp;觸發 onreadystatechange：最後一次調用 onreadystatechange 回調。<br />
              &emsp;&emsp;觸發 onload 或 onerror：<br />
              &emsp;&emsp;如果請求成功（HTTP 狀態碼為 2xx 或 3xx），觸發 onload 事件。<br />
              &emsp;&emsp;如果請求失敗（如網路錯誤、超時等），觸發 onerror 事件。<br />
            </p>
            <p><strong>瀏覽器的內部機制與Thread</strong></p>
            <img src="../images/ProcessModel10.png" alt="">
            <p>
              &emsp;1. Main Thread<br />
              &emsp;&emsp;JavaScript 執行：Main Thread負責執行所有的 JavaScript 程式碼，包括調用 send() 方法的程式碼。<br />
              &emsp;&emsp;事件循環：Main Thread負責處理事件循環，調度Task Queue中的任務。<br />
              &emsp;2. Network Thread<br />
              &emsp;&emsp;網路請求處理：當調用 send() 方法時，網路請求被委派給瀏覽器的Network Thread，以非阻塞的方式處理。<br />
              &emsp;&emsp;數據接收：Network Thread負責接收伺服器的Response ，並將相關事件（如 onreadystatechange）添加到Main Thread的Task Queue中。<br />
              &emsp;3. 任務調度<br />
              &emsp;&emsp;Event Loop：Main Thread的事件循環負責調度任務，當Network Thread接收到數據並觸發事件時，這些事件的回調函數會被添加<br />
              &emsp;&emsp;到Task Queue，等待Main Thread執行。<br />
              &emsp;&emsp;非阻塞：由於網路請求在Network Thread中處理，Main Thread可以繼續執行其他程式碼，不會因為等待網路請求而被阻塞。<br />
            </p>
            <pre>
                                                            調用 xhr.send()
                                                                   |
                                                                   V
                                                       瀏覽器檢查請求設定並準備請求
                                                                   |
                                                                   V
                                                  瀏覽器委派網路請求給Network Thread
                                                                   |
                                                                   V
                                                  Network Thread處理網路通訊，發送請求
                                                                   |
                                                                   V
                                                請求發出後，Main Thread繼續執行後續程式碼
                                                                   |
                                                                   V
                                              Network Thread接收Response ，更新 readyState
                                                                   |
                                                                   V
                                    觸發對應的事件（如 onreadystatechange），添加到Main Thread的Task Queue
                                                                   |
                                                                   V
                                                  Main Thread的事件循環調度並執行回調函數
                                                                   |
                                                                   V
                                                 在回調函數中處理Response 數據，更新頁面等
            </pre>
            <h5>4. 處理回應 (response)</h5>
            <p>
              可以透過 <code>onreadystatechange</code> 或
              <code>onload</code> 監聽請求的狀態變化並處理回應：
            </p>

            <pre class="prettyprint">
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText); // 輸出伺服器回應的資料
    }
};</pre
            >



            <pre class="prettyprint">
xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
        console.log(xhr.responseText); // 處理回應資料
    } else {
        console.error('請求失敗');
    }
};</pre
            >
          </section>

          <section id="_fetch">
            <h3>Fetch</h3>
            <h4>什麼是 Fetch？</h4>
            <p>
              <strong>Fetch API</strong> 是
              <strong>XMLHttpRequest</strong> 的現代替代品。它使用
              <strong>Promise</strong> 來處理非同步操作，設計更加靈活且簡潔。
            </p>
            <pre class="prettyprint">
fetch('https://api.example.com/products')
  .then(response => {
    if (!response.ok) {
      throw new Error('網路回應有誤：' + response.statusText);
    }
    return response.json();  // 解析 JSON 資料
  })
  .then(products => {
    console.log(products);  // 處理並顯示產品
  })
  .catch(error => {
    console.error('Fetch 操作中出現問題：', error);
  });</pre
            >

            <h4>使用 Fetch 發送 POST 請求</h4>
            <p>假設用戶將產品加入購物車，可以使用 Fetch 發送 POST 請求：</p>
            <pre class="prettyprint">
fetch('https://api.example.com/cart', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    productId: 12345,
    quantity: 1
  })
})
  .then(response => response.json())
  .then(data => console.log('產品已加入購物車：', data))
  .catch(error => console.error('加入購物車時發生錯誤：', error));</pre
            >
          </section>

          <section id="_fetch_xhr_comparison">
            <h3>XMLHttpRequest vs. Fetch</h3>
            <h4>XMLHttpRequest 範例：</h4>
            <pre class="prettyprint">
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onload = function() {
  if (xhr.status >= 200 && xhr.status < 300) {
    var data = JSON.parse(xhr.responseText);
    console.log(data);
  } else {
    console.error('Error:', xhr.statusText);
  }
};
xhr.onerror = function() {
  console.error('Request failed');
};
xhr.send();
            </pre>

            <h4>Fetch 範例：</h4>
            <pre class="prettyprint">
fetch('https://api.example.com/data')
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));</pre
            >
            <br><br>
            <table border="1" cellpadding="8" cellspacing="0">
              <thead>
                <tr>
                  <th>比較</th>
                  <th>Fetch API</th>
                  <th>XMLHttpRequest</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>語法和易用性</strong></td>
                  <td>- 基於 Promise，語法更簡潔<br>- 更易於閱讀和維護</td>
                  <td>- 基於回調函數，語法較為繁瑣<br>- 需要處理多個事件</td>
                </tr>
                <tr>
                  <td><strong>非同步步處理方式</strong></td>
                  <td>- 使用 Promise<br>- 支持 <code>async/await</code> 語法</td>
                  <td>- 使用事件和回調函數<br>- 不支援 Promise</td>
                </tr>
                <tr>
                  <td><strong>同步請求</strong></td>
                  <td>- 不支持同步請求</td>
                  <td>- 支持同步請求（但已被廢棄，不推薦使用）</td>
                </tr>
                <tr>
                  <td><strong>請求攔截和取消</strong></td>
                  <td>- 支持使用 <code>AbortController</code> 取消請求</td>
                  <td>- 可使用 <code>xhr.abort()</code> 方法取消請求</td>
                </tr>
                <tr>
                  <td><strong>請求進度監聽</strong></td>
                  <td>- 無法直接監聽請求進度<br>- 不支援上傳進度監聽</td>
                  <td>- 支持 <code>onprogress</code> 事件<br>- 可監聽下載和上傳進度</td>
                </tr>
                <tr>
                  <td><strong>錯誤處理</strong></td>
                  <td>- 只有在網絡錯誤時會拒絕 Promise<br>- HTTP 錯誤（如 404、500）不會拋出錯誤，需要手動檢查 <code>response.ok</code></td>
                  <td>- 可通過 <code>xhr.status</code> 判斷 HTTP 狀態碼<br>- 在錯誤時觸發 <code>onerror</code> 事件</td>
                </tr>
                <tr>
                  <td><strong>Response類型</strong></td>
                  <td>- 支持多種Response類型，如 <code>response.json()</code>、<code>response.text()</code>、<code>response.blob()</code>、<code>response.arrayBuffer()</code>、<code>response.formData()</code></td>
                  <td>- Response存儲在 <code>responseText</code>（字符串）和 <code>responseXML</code>（XML 文檔）中</td>
                </tr>
                <tr>
                  <td><strong>Request header設置</strong></td>
                  <td>- 使用 <code>Headers</code> 物件設置Request header<br>- 某些頭部不可修改（如 <code>Referer</code>、<code>User-Agent</code>）</td>
                  <td>- 使用 <code>setRequestHeader()</code> 方法設置Request header<br>- 可以設置更多自定義頭部</td>
                </tr>
                <tr>
                  <td><strong>跨域請求（CORS）</strong></td>
                  <td>- 默認採用 CORS<br>- 支持跨域請求，但需要伺服器允許</td>
                  <td>- 需要額外設定才能進行跨域請求<br>- 可能受到更多限制</td>
                </tr>
                <tr>
                  <td><strong>流式處理</strong></td>
                  <td>- 支持流式Response（Streaming）<br>- 可逐步處理大型數據</td>
                  <td>- 不支持流式Response<br>- 必須在Response完全接收後才能處理</td>
                </tr>
                <tr>
                  <td><strong>請求取消（Abort）</strong></td>
                  <td>- 支持使用 <code>AbortController</code> 取消請求</td>
                  <td>- 可使用 <code>xhr.abort()</code> 方法取消請求</td>
                </tr>
                <tr>
                  <td><strong>超時設置</strong></td>
                  <td>- 不直接支持超時設置<br>- 需要使用 <code>Promise.race()</code> 實現超時控制</td>
                  <td>- 支持 <code>xhr.timeout</code> 屬性設置超時時間<br>- 可監聽 <code>ontimeout</code> 事件</td>
                </tr>
                <tr>
                  <td><strong>上傳文件</strong></td>
                  <td>- 支持通過 <code>fetch</code> 上傳文件<br>- 但無法監聽上傳進度</td>
                  <td>- 支持上傳文件<br>- 可通過 <code>xhr.upload.onprogress</code> 監聽上傳進度</td>
                </tr>
                <tr>
                  <td><strong>自動發送 Cookie</strong></td>
                  <td>- 默認不發送 Cookie<br>- 需要設置 <code>credentials</code> 選項<br>- <code>credentials: 'same-origin'</code> 或 <code>credentials: 'include'</code></td>
                  <td>- 默認會發送並接收 Cookie<br>- 可通過 <code>withCredentials</code> 屬性控制</td>
                </tr>
                <tr>
                  <td><strong>HTTP Response碼處理</strong></td>
                  <td>- 需要手動檢查 <code>response.ok</code> 或 <code>response.status</code> 來判斷是否成功</td>
                  <td>- 可直接通過 <code>xhr.status</code> 判斷請求是否成功</td>
                </tr>
                <tr>
                  <td><strong>原生支援度</strong></td>
                  <td>- 現代瀏覽器原生支持<br>- IE 不支持 Fetch API，需要使用 polyfill</td>
                  <td>- 所有主流瀏覽器均支持，包括較舊版本的 IE</td>
                </tr>
                <tr>
                  <td><strong>調試和追蹤</strong></td>
                  <td>- 調試較為困難，錯誤信息可能不夠詳細</td>
                  <td>- 調試較為方便，可在開發者工具中查看請求詳細信息</td>
                </tr>
                <tr>
                  <td><strong>HTTP 改寫或重導向</strong></td>
                  <td>- <code>fetch</code> 會自動處理 HTTP 重導向<br>- 可設置 <code>redirect</code> 選項控制</td>
                  <td>- 需要手動處理重導向，較為麻煩</td>
                </tr>
                <tr>
                  <td><strong>安全性</strong></td>
                  <td>- 遵循嚴格的 CORS 政策<br>- 某些頭部不可修改，增強安全性</td>
                  <td>- 可能存在被利用的風險，需要謹慎處理</td>
                </tr>
                <tr>
                  <td><strong>使用場景</strong></td>
                  <td>- 適合現代化的應用開發<br>- 需要處理 Promise 的情況</td>
                  <td>- 適合需要兼容舊瀏覽器<br>- 需要監聽進度或同步請求</td>
                </tr>
                <tr>
                  <td><strong>API 靈活性</strong></td>
                  <td>- API 簡潔但某些功能有限<br>- 需要結合其他 API（如 Streams、AbortController）實現高級功能</td>
                  <td>- API 功能全面<br>- 支持更多細節控制和設定</td>
                </tr>
              </tbody>
            </table>
            
          </section>
        </section>

        <section id="_promise與非同步處理">
          <h2>Promise 與非同步處理</h2>
          <section id="_promise">
            <h3>Promise</h3>
            <p>Promise 照字面意思是「承諾」，它代表的是一個非同步操作在未來某個時刻會返回數據或錯誤給調用者。Promise 只會在操作成功（或失敗）時返回一次結果。根據 MDN 文件的定義，Promise 用來表示一個非同步操作的最終完成（resolved）或失敗（rejected）及其結果值。</p>
            <h4 id="_promise的狀態">Promise 的狀態</h4>
            <ul>
              <li><strong>pending</strong>：初始狀態，尚未完成。</li>
              <li>
                <strong>fulfilled</strong>：操作成功，已執行
                <code>resolve()</code>。
              </li>
              <li>
                <strong>rejected</strong>：操作失敗，已執行
                <code>reject()</code>。
              </li>
            </ul>
            <p>
              當 Promise 從 <strong>pending</strong> 變為
              <strong>fulfilled</strong> 或
              <strong>rejected</strong> 後，其狀態便不再變更。
            </p>

            <h4 id="_基本結構">基本結構</h4>
            <pre class="prettyprint">
let promise = new Promise((resolve, reject) => {
  let success = true;

  if (success) {
    resolve('操作成功');
  } else {
    reject('操作失敗');
  }
});

promise.then(result => {
  console.log(result);  // 輸出 '操作成功'
})
.catch(error => {
  console.error(error);  // 輸出 '操作失敗'
});</pre
            >

            <h4 id="_鏈式結構">鏈式結構</h4>
            <pre class="prettyprint">
fetch("https://openlibrary.org/search.json?q=the+lord+of+the+rings")
.then(response => {
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  console.log(response);            // Logs the raw response object
  return response.json();           // Call the `json()` method to parse the response as JSON
})
.then(data => {
  console.log(data);                // Logs the parsed JSON data
})
.catch(error => {
  console.error(error);             // Logs any error that occurs during the fetch or JSON parsing
});</pre
            >
          </section>

          <section id="_promise_all">
            <h3>Promise.all()</h3>
            <h4 id="_promise_all_使用範例">使用範例</h4>
            <p>
              <strong>Promise.all()</strong> 用來處理多個 Promise
              並行執行。它允許傳入一個 Promise 陣列，當所有的 Promise
              都成功時，返回一個新的 Promise，該 Promise
              的結果是一個包含所有結果的陣列。如果其中任何一個 Promise
              被拒絕，<code>Promise.all()</code> 會立即返回一個被拒絕的
              Promise，並且錯誤會傳遞給 .catch()。
            </p>

            <pre class="prettyprint">
Promise.all([promise1, promise2, promise3])
  .then(results => {
    // 當所有的 Promise 成功完成時
    console.log(results);  // 結果是一個陣列，包含每個 Promise 的結果
  })
  .catch(error => {
    // 當任一 Promise 失敗時
    console.error(error);
  });</pre
            >

            <h4 id="_promise_all的工作方式">Promise.all() 的工作方式</h4>
            <p>
              <code>Promise.all()</code> 並行執行所有傳入的
              Promise，這對提高效率非常重要，尤其是當你需要並行執行多個耗時的操作時（如多個網路請求）。
            </p>
            <ul>
              <li>
                <strong>成功狀態</strong>：當所有的 Promise
                都成功解決時，返回一個包含每個 Promise
                結果的陣列，順序與傳入順序相同。
              </li>
              <li>
                <strong>錯誤處理</strong>：如果任一 Promise 被拒絕，<code
                  >Promise.all()</code
                >
                會立即進入 <code>.catch()</code>，返回第一個失敗的錯誤。
              </li>
            </ul>

            <h4>Promise.all()實際範例</h4>
            <pre class="prettyprint">
const fetchGatsby = fetch("https://openlibrary.org/search.json?q=the+great+gatsby")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  });

const fetchLordOfTheRings = fetch("https://openlibrary.org/search.json?q=the+lord+of+the+ring")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  });

const fetchPrideAndPrejudice = fetch("https://openlibrary.org/search.json?q=pride+and+prejudice")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  });

Promise.all([fetchGatsby, fetchLordOfTheRings, fetchPrideAndPrejudice])
  .then(([gatsbyData, lotrData, prideData]) => {
    console.log('The Great Gatsby:', gatsbyData);
    console.log('The Lord of the Rings:', lotrData);
    console.log('Pride and Prejudice:', prideData);
  })
  .catch(error => {
    console.error('Error fetching data:', error);
  });

// for promise fail Demo
const fetchPrideAndPrejudice = new Promise((resolve, reject) => {
  // Simulating an error
  setTimeout(() => reject(new Error('Simulated failure for Pride and Prejudice')), 1000);
});
            </pre>
          </section>

      </main>
    </div>

    <footer>
      <p></p>
    </footer>
    <div id="footer">
      <div id="footer-text" class="pageclick">
        <a href="./function2.html" class="pageclick left">上一頁</a>
        <a href="./index.html" class="pageclick center">回目錄</a>
        <a href="./newmypart.html" class="pageclick right">下一頁</a>
      </div>
    </div>
  </body>
</html>
