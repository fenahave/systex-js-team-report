<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript 同步與非同步</title>
    <script src="../js/run_pprettify.js"></script>
    <link rel="stylesheet" href="../css/style.css" />
    <link rel="stylesheet" href="../css/pretty.css" />
    <style>
      #container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #header,
      main {
        width: 80%;
        max-width: 1200px;
      }
      #header {
        text-align: left;
      }
      main {
        margin-top: 20px;
      }
      #toc ul {
        list-style-type: disc;
        padding-left: 20px;
      }
      #toc li {
        margin: 5px 0;
      }
      #toc a {
        text-decoration: none;
        color: #1a73e8;
      }
      #toc a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="header">
        <header>
          <h1>JavaScript 同步與非同步</h1>
        </header>
        <nav id="toc" class="toc">
          <div id="toctitle">目錄</div>
          <ul class="sectlevel1">
            <li>
              <a href="#_同步與非同步概念">同步與非同步概念</a>
              <ul>
                <li><a href="#_同步是什麼">同步是什麼？</a></li>
                <li><a href="#_非同步是什麼">非同步是什麼？</a></li>
                <li>
                  <a href="#_為什麼Javascript可以非同步"
                    >為什麼 JavaScript 可以非同步？</a
                  >
                </li>
                <li><a href="#_為什麼需要非同步">為什麼需要非同步</a></li>
              </ul>
            </li>
            <li>
              <a href="#_ajax與數據請求">AJAX 與數據請求</a>
              <ul>
                <li><a href="#_什麼是_ajax">什麼是 AJAX?</a></li>
                <li><a href="#_xmlhttprequest">XMLHttpRequest</a></li>
                <li><a href="#_fetch">Fetch</a></li>
                <li>
                  <a href="#_fetch_xhr_comparison">XMLHttpRequest vs. Fetch</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#_promise與非同步處理">Promise 與非同步處理</a>
              <ul>
                <li>
                  <a href="#_promise">Promise</a>
                  <ul>
                    <li><a href="#_promise的狀態">Promise 的狀態</a></li>
                    <li><a href="#_基本結構">基本結構</a></li>
                    <li><a href="#_鏈式結構">鏈式結構</a></li>
                    <li><a href="#_靈活應用">Promise 的靈活應用</a></li>
                    <li><a href="#_promise_all">Promise.all()</a></li>
                    <li><a href="#_promise_all_使用範例">Promise.all() 實際範例</a></li>
                    <li><a href="#_promise_allSettled">Promise.allSettled()</a></li>
                    <li><a href="#_promise_allSettled_使用範例">Promise.allSettled() 實際範例</a></li>
                    <li><a href="#_promise_race">Promise.race()</a></li>
                    <li><a href="#_promise_race_使用範例">Promise.race() 實際範例</a></li>
                    <li><a href="#_promise_any">Promise.any()</a></li>
                    <li><a href="#_promise_any_使用範例">Promise.any() 實際範例</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#_promise_方法比較">Promise 方法比較</a>
                </li>
              </ul>
            </li>
          </ul>
        </nav>
      </div>

      <main>
        <section id="_同步與非同步概念">
          <h2>同步與非同步概念</h2>

          <section id="_同步是什麼">
            <h3>同步是什麼？</h3>
            <p>「同步」指的是一次只能做一件事情。</p>
            <p>
              JavaScript 是「單執行緒 (Single-Thread)」語言，這意味著它一次只能執行一個任務。所有操作都會按順序執行，這是同步的概念。
            </p>
            <pre class="prettyprint">
// Synchronous code example
console.log("Start");

console.log("Performing a synchronous task");

console.log("End");
            </pre>
          </section>

          <section id="_非同步是什麼">
            <h3>非同步是什麼？</h3>
            <p>
              非同步允許多個任務並行進行，無需等待前一個任務完成。非同步處理讓 JavaScript 可以在不阻塞主線程的情況下處理耗時操作，比如網絡請求或定時器。
            </p>
            <pre class="prettyprint">
console.log("hello");
setTimeout(function() {
  console.log("End");
}, 1000);

for(let i = 0; i < 4; i++) {
    console.log(i);
}
            </pre>
            <p>
              在這個例子中，<code>setTimeout</code> 是一個非同步操作，並不會阻塞 JavaScript 執行其他代碼。即使我們指定它在 1000 毫秒後執行，但 JavaScript 會繼續執行後續的 <code>for</code> 迴圈，而不必等待 <code>setTimeout</code> 完成。
            </p>
          </section>

          <section id="_為什麼需要非同步">
            <h3>為什麼需要非同步？什麼時候會用到？</h3>
            <h4>Blocking</h4>

            <p>阻塞（blocking） 是指程式在執行某個操作時，必須等待該操作完成，才能繼續執行後續的程式碼。在阻塞過程中，程式的執行會暫停，等待某個資源或操作完成，這段時間內，其他操作無法進行。這通常發生在某些需要較長時間才能完成的操作上，比如以下：</p>

            <ul>
              <li><strong>向 API 發送請求：</strong>若是同步處理，JavaScript 在等待 API 回應時，頁面會被鎖住，什麼操作都無法進行。</li>
              <li><strong>setTimeout：</strong>定時器如果是同步的，則必須等待時間結束，其他代碼無法執行。</li>
              <li><strong>DOM 操作：</strong>若是同步處理，則在操作 DOM 的過程中，整個頁面無法進行其他交互。</li>
            </ul>
            <p>
              為了避免這些阻塞問題，JavaScript 引入了非同步機制，讓長時間執行的任務可以在後台進行，並在完成後通知主執行線程。
            </p>
            <h4 style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
              <a href="./blocking-demo.html" style="color: #007bff; text-decoration: none; font-weight: bold;"">點擊這裡操作頁面以了解阻塞概念</a>
            </h4>
          </section>

          <section id="_為什麼Javascript可以非同步">
            <h3>為什麼 JavaScript 可以非同步？</h3>
            <p>
              雖然 JavaScript 是單執行緒語言，但它可以透過與瀏覽器的 Web API 進行互動，實現非同步處理。這樣，JavaScript 本身依然是同步的，但透過 Web API 它能夠並行處理多個任務，而不會阻塞主線程。
            </p>
            <p>
              這些 Web API（例如：<code>setTimeout</code>、<code>XMLHttpRequest</code>、<code>fetch</code>）允許瀏覽器代為處理異步操作，並在任務完成後將結果傳回 JavaScript 引擎。
            </p>

            <h4>JavaScript 的執行機制</h4>
            <p>
              為了理解 JavaScript 是如何處理非同步操作的，我們需要了解它的執行機制，主要包括以下幾個部分：
            </p>

            <ul>
              <li><strong>Call Stack (調用堆疊)：</strong>JavaScript 執行同步代碼時，會依次將函數推入調用堆疊，並從堆疊中彈出執行完成的函數。</li>
              <li><strong>Web API：</strong>Web API 是由瀏覽器提供的，專門用來處理異步操作。當 JavaScript 遇到像 <code>setTimeout</code> 或 <code>fetch</code> 這樣的異步操作時，會將它們委託給 Web API 處理，並繼續執行其他同步代碼。</li>
              <li><strong>Callback Queue (回調隊列)：</strong>當 Web API 完成異步操作後，會將回調函數放入回調隊列，等待主線程空閒時執行。</li>
              <li><strong>Microtask Queue (微任務隊列)：</strong>這是專門用來處理更高優先級的任務，比如 <code>Promise</code> 的回調。微任務在每次事件循環結束後會立即執行。</li>
              <li><strong>Macrotask Queue (宏任務隊列)：</strong>宏任務包括 <code>setTimeout</code> 和 <code>setInterval</code> 等異步操作。這些任務的回調會在微任務執行完畢後執行。</li>
            </ul>
            <div style="display: flex; justify-content: space-around;">
              <img src="../images/micro-task.png" alt="micro-macro-task" style="max-width: 45%; height: auto;">
              <img src="../images/macro-task.png" alt="macro-macro-task" style="max-width: 45%; height: auto;">
            </div>


            <h4>事件循環 (Event Loop)</h4>
            <p>
              JavaScript 使用「事件循環 (Event Loop)」來協調這些任務。事件循環會不斷檢查調用堆疊是否為空，如果為空，就會從回調隊列中取出任務執行，從而實現非同步操作。
            </p>

            <h4>完整執行流程</h4>
            <p>完整的非同步執行流程如下：</p>
            <ol>
              <li>JavaScript 將同步代碼推入 Call Stack 執行。</li>
              <li>當遇到異步操作時，將其交給 Web API 處理，並繼續執行其他代碼。</li>
              <li>Web API 完成任務後，將回調函數放入 Callback Queue 或 Microtask Queue 中。</li>
              <li>事件循環檢查 Call Stack 是否空閒，若空閒則依次處理回調隊列中的回調。</li>
              <li>Microtask Queue 會優先於 Macrotask Queue 執行。</li>
            </ol>

            <img src="../images/eventloop.png" alt="eventloop">



            <h4>例子展示非同步運作</h4>
            <pre class="prettyprint">
console.log("Start");

setTimeout(() => {
  console.log("Timeout callback");
}, 1000);

Promise.resolve().then(() => {
  console.log("Promise callback");
});

console.log("End");

// 這段代碼會輸出：
// Start
// End
// Promise callback
// Timeout callback
            </pre>
            <p>原因是 Promise 的回調會進入微任務隊列（Microtask Queue），而 <code>setTimeout</code> 的回調則進入宏任務隊列（Macrotask Queue）。微任務會優先執行，因此 Promise 的回調會在 <code>setTimeout</code> 之前執行。</p>

            <h4 style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
              <a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" style="color: #007bff; text-decoration: none; font-weight: bold;">🎥 點擊這裡查看完整的事件循環可視化演示</a>
            </h4>
          </section>
        </section>


      <section>
        <section id="_ajax與數據請求">
          <h2>AJAX 與數據請求</h2>
          <section id="_什麼是_ajax">
            <h3>什麼是 AJAX?</h3>
            <p>
              AJAX（Asynchronous
              <a
                href="https://developer.mozilla.org/zh-TW/docs/Glossary/JavaScript"
                >JavaScript</a
              >
              And
              <a href="https://developer.mozilla.org/en-US/docs/Glossary/XML"
                >XML</a
              >，非同步 JavaScript 與 XML）是結合了
              <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/HTML"
                >HTML</a
              >、<a href="https://developer.mozilla.org/zh-TW/docs/Glossary/CSS"
                >CSS</a
              >、JavaScript、<a
                href="https://developer.mozilla.org/zh-TW/docs/Glossary/DOM"
                >DOM</a
              >、還有
              <code>XMLHttpRequest</code> 物件，以建立更複雜的網頁應用。AJAX
              允許網頁只更新所需的部分，而無需重新載入整個頁面。雖然名字中有
              XML，但它也可以用現今廣泛使用的 JSON 及其他資料類型（如 HTML, Form
              Data, Binary Data, Blob, ArrayBuffer）進行資料交換。
            </p>
          </section>

          <section id="_xmlhttprequest">
            <h3>XMLHttpRequest</h3>
            <p>
              XMLHttpRequest 是 JavaScript 中的物件，允許網頁向伺服器發送 HTTP
              或 HTTPS
              請求，並在不重新載入整個網頁的情況下接收回應資料。這項技術是實現
              AJAX 的重要組成部分，能讓網頁內容動態更新。雖然現在常用 fetch()
              技術，但 XMLHttpRequest 在某些較舊的項目中仍然被廣泛使用。
            </p>

            <h4>XMLHttpRequest 基本概念</h4>
            <h5>1. 建立 XMLHttpRequest 物件</h5>
            <pre class="prettyprint">let xhr = new XMLHttpRequest();</pre>
            <p>
              此時仍為同步語句，非同步操作尚未開始<br />
              物件創建：創建了一個新的XMLHttpRequest物件<br />
              記憶體分配：xhr物件被分配在記憶體的Heap中<br />
              初始狀態：此時xhr.readyState的值為0，表示UNSENT<br />
            </p>
            <p><strong>readyState 狀態值：</strong></p>
            <ul>
              <li>0: UNSENT – 請求尚未打開。</li>
              <li>1: OPENED – 請求已打開，但尚未發送。</li>
              <li>2: HEADERS_RECEIVED – 已收到伺服器回應標頭。</li>
              <li>3: LOADING – 請求正在處理，回應的資料正在接收。</li>
              <li>4: DONE – 請求已完成，回應可用。</li>
            </ul>
            <h5>2. 打開請求 (open)</h5>
            <pre class="prettyprint">
xhr.open('GET', 'https://api.example.com/data', true);</pre
            >
            <br />
            <p>
              該方法初始化了一個HTTP請求，只聽了請求方法與URL，第三個參數為true表示非同步<br />
              此時xhr.readyState的值變為1<br />
              調用 open() 方法僅僅是設定請求參數，還沒開始網路通訊<br />
            </p>
   
            <h5>3. 發送請求 (send)</h5>
            <pre class="prettyprint">xhr.send();</pre>
            <p>如果是 POST 請求，可以將資料以字串格式傳入 send() 中：</p>
            <pre class="prettyprint">
let data = JSON.stringify({ name: "Oscar", age: 24 });
xhr.send(data);</pre
            >
            <br />
            <p><strong>此時瀏覽器做了什麼？</strong></p>
            <p>
              一、準備發送請求<br />
              &emsp;1.檢查 XMLHttpRequest 物件的狀態<br />
              &emsp;&emsp;確認狀態為已初始化：確保已經調用了 open() 方法，readyState 為 1（OPENED）。<br />
              &emsp;&emsp;確認請求已設定：請求方法、URL、同步或非同步步標誌等已正確設置。<br />
              &emsp; 2.處理Request Headers<br />
              &emsp;&emsp;應用預設的Request Headers：如 Accept、User-Agent 等。<br />
              &emsp;&emsp;應用開發者設置的Request Headers：如果在調用 send() 之前使用 setRequestHeader() 設置了自定義的Request Headers，<br />
              &emsp;&emsp;這些Headers會在請求中被包含。<br />
              &emsp;3.Request Body<br />
              &emsp;&emsp;處理Request Body數據：如果請求方法為 POST、PUT 等，並且在 send() 方法中傳入了Request Body，瀏覽器會對數據進行適當的編碼<br />
              &emsp;&emsp;（如將 JavaScript 物件轉換為 JSON 字符串）。<br />
            </p>
            <p>
              二、發送網路請求<br />
              &emsp;1. 開始網路通訊<br />
              &emsp;&emsp;委派給Network Thread：瀏覽器將網路請求交給Network Thread處理，以避免阻塞Main Thread（JavaScript 執行環境）。<br />
              &emsp;&emsp;建立連接：如果與目標伺服器之間沒有現有的連接，瀏覽器會建立一個新的 TCP 連接，可能會進行 DNS 查詢、TLS 握手等。<br />
              &emsp;2. 發送 HTTP 請求<br />
              &emsp;&emsp;構建 HTTP 請求：將請求方法、URL、HTTP 版本、Request header和Request Body組合成完整的 HTTP 請求報文。<br />
              &emsp;&emsp;發送請求報文：通過網路將請求報文發送給目標伺服器。<br />

            </p>
            <p>
              三、處理請求過程中的事件<br />
              &emsp;1. 更新 readyState<br />
              &emsp;&emsp;readyState 變化：請求發送後，readyState 仍為 1。隨著請求的進展，readyState 會發生1~4的變化：<br />
              &emsp;2. 觸發事件處理器<br />
              &emsp;&emsp;onreadystatechange 事件：每當 readyState 發生變化時，瀏覽器會調用 onreadystatechange 回調函數。<br />
            </p>
            <p>
              四、接收Response <br />
              &emsp;1. 收到Response Header<br />
              &emsp;&emsp;狀態碼和狀態文本：瀏覽器接收到伺服器的Response Header，獲取 HTTP 狀態碼（如 200、404）和狀態文本（如 OK、Not Found）。<br />
              &emsp;&emsp;Response Header資訊：獲取伺服器返回的Response Header，如 Content-Type、Content-Length、Set-Cookie 等。<br />
              &emsp;2. 更新 readyState 為 2<br />
              &emsp;&emsp;觸發 onreadystatechange：readyState 變為 2，觸發 onreadystatechange 回調。<br />
              &emsp;3. 接收Response 體<br />
              &emsp;&emsp;數據流接收：瀏覽器開始接收Response 體數據，這個過程可能是漸進式的，特別是對於大型文件。<br />
              &emsp;&emsp;更新 readyState 為 3：<br />
              &emsp;&emsp;觸發 onreadystatechange：readyState 變為 3，表示正在接收Response 體，觸發 onreadystatechange 回調。<br />
              &emsp;&emsp;觸發 onprogress：在接收過程中，多次觸發 onprogress 事件，可用於更新下載進度。<br />
              &emsp;4. 接收完成<br />
              &emsp;&emsp;更新 readyState 為 4：<br />
              &emsp;&emsp;readyState 變為 4（DONE），表示Response 已完整接收。<br />
              &emsp;&emsp;觸發 onreadystatechange：最後一次調用 onreadystatechange 回調。<br />
              &emsp;&emsp;觸發 onload 或 onerror：<br />
              &emsp;&emsp;如果請求成功（HTTP 狀態碼為 2xx 或 3xx），觸發 onload 事件。<br />
              &emsp;&emsp;如果請求失敗（如網路錯誤、超時等），觸發 onerror 事件。<br />
            </p>
            <p><strong>瀏覽器的內部機制與Thread</strong></p>
            <img src="../images/ProcessModel10.png" alt="">
            <p>
              &emsp;1. Main Thread<br />
              &emsp;&emsp;JavaScript 執行：Main Thread負責執行所有的 JavaScript 程式碼，包括調用 send() 方法的程式碼。<br />
              &emsp;&emsp;事件循環：Main Thread負責處理事件循環，調度Task Queue中的任務。<br />
              &emsp;2. Network Thread<br />
              &emsp;&emsp;網路請求處理：當調用 send() 方法時，網路請求被委派給瀏覽器的Network Thread，以非阻塞的方式處理。<br />
              &emsp;&emsp;數據接收：Network Thread負責接收伺服器的Response ，並將相關事件（如 onreadystatechange）添加到Main Thread的Task Queue中。<br />
              &emsp;3. 任務調度<br />
              &emsp;&emsp;Event Loop：Main Thread的事件循環負責調度任務，當Network Thread接收到數據並觸發事件時，這些事件的回調函數會被添加<br />
              &emsp;&emsp;到Task Queue，等待Main Thread執行。<br />
              &emsp;&emsp;非阻塞：由於網路請求在Network Thread中處理，Main Thread可以繼續執行其他程式碼，不會因為等待網路請求而被阻塞。<br />
            </p>
            <pre>
                                                            調用 xhr.send()
                                                                   |
                                                                   V
                                                       瀏覽器檢查請求設定並準備請求
                                                                   |
                                                                   V
                                                  瀏覽器委派網路請求給Network Thread
                                                                   |
                                                                   V
                                                  Network Thread處理網路通訊，發送請求
                                                                   |
                                                                   V
                                                請求發出後，Main Thread繼續執行後續程式碼
                                                                   |
                                                                   V
                                              Network Thread接收Response ，更新 readyState
                                                                   |
                                                                   V
                                    觸發對應的事件（如 onreadystatechange），添加到Main Thread的Task Queue
                                                                   |
                                                                   V
                                                  Main Thread的事件循環調度並執行回調函數
                                                                   |
                                                                   V
                                                 在回調函數中處理Response 數據，更新頁面等
            </pre>
            <h5>4. 處理回應 (response)</h5>
            <p>
              可以透過 <code>onreadystatechange</code> 或
              <code>onload</code> 監聽請求的狀態變化並處理回應：
            </p>

            <pre class="prettyprint">
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText); // 輸出伺服器回應的資料
    }
};</pre
            >



            <pre class="prettyprint">
xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
        console.log(xhr.responseText); // 處理回應資料
    } else {
        console.error('請求失敗');
    }
};</pre
            >
          </section>

          <section id="_fetch">
            <h3>Fetch</h3>
            <h4>什麼是 Fetch？</h4>
            <p>
              <strong>Fetch API</strong> 是
              <strong>XMLHttpRequest</strong> 的現代替代品。它使用
              <strong>Promise</strong> 來處理非同步操作，設計更加靈活且簡潔。
            </p>
            <pre class="prettyprint">
fetch('https://api.example.com/products')
  .then(response => {
    if (!response.ok) {
      throw new Error('網路回應有誤：' + response.statusText);
    }
    return response.json();  // 解析 JSON 資料
  })
  .then(products => {
    console.log(products);  // 處理並顯示產品
  })
  .catch(error => {
    console.error('Fetch 操作中出現問題：', error);
  });</pre
            >

            <h4>使用 Fetch 發送 POST 請求</h4>
            <p>假設用戶將產品加入購物車，可以使用 Fetch 發送 POST 請求：</p>
            <pre class="prettyprint">
fetch('https://api.example.com/cart', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    productId: 12345,
    quantity: 1
  })
})
  .then(response => response.json())
  .then(data => console.log('產品已加入購物車：', data))
  .catch(error => console.error('加入購物車時發生錯誤：', error));</pre
            >
          </section>

          <section id="_fetch_xhr_comparison">
            <h3>XMLHttpRequest vs. Fetch</h3>
            <h4>XMLHttpRequest 範例：</h4>
            <pre class="prettyprint">
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onload = function() {
  if (xhr.status >= 200 && xhr.status < 300) {
    var data = JSON.parse(xhr.responseText);
    console.log(data);
  } else {
    console.error('Error:', xhr.statusText);
  }
};
xhr.onerror = function() {
  console.error('Request failed');
};
xhr.send();
            </pre>

            <h4>Fetch 範例：</h4>
            <pre class="prettyprint">
fetch('https://api.example.com/data')
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));</pre
            >
            <br><br>
            <table border="1" cellpadding="8" cellspacing="0">
              <thead>
                <tr>
                  <th>比較</th>
                  <th>Fetch API</th>
                  <th>XMLHttpRequest</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>語法和易用性</strong></td>
                  <td>- 基於 Promise，語法更簡潔<br>- 更易於閱讀和維護</td>
                  <td>- 基於回調函數，語法較為繁瑣<br>- 需要處理多個事件</td>
                </tr>
                <tr>
                  <td><strong>非同步步處理方式</strong></td>
                  <td>- 使用 Promise<br>- 支持 <code>async/await</code> 語法</td>
                  <td>- 使用事件和回調函數<br>- 不支援 Promise</td>
                </tr>
                <tr>
                  <td><strong>同步請求</strong></td>
                  <td>- 不支持同步請求</td>
                  <td>- 支持同步請求（但已被廢棄，不推薦使用）</td>
                </tr>
                <tr>
                  <td><strong>請求攔截和取消</strong></td>
                  <td>- 支持使用 <code>AbortController</code> 取消請求</td>
                  <td>- 可使用 <code>xhr.abort()</code> 方法取消請求</td>
                </tr>
                <tr>
                  <td><strong>請求進度監聽</strong></td>
                  <td>- 無法直接監聽請求進度<br>- 不支援上傳進度監聽</td>
                  <td>- 支持 <code>onprogress</code> 事件<br>- 可監聽下載和上傳進度</td>
                </tr>
                <tr>
                  <td><strong>錯誤處理</strong></td>
                  <td>- 只有在網絡錯誤時會拒絕 Promise<br>- HTTP 錯誤（如 404、500）不會拋出錯誤，需要手動檢查 <code>response.ok</code></td>
                  <td>- 可通過 <code>xhr.status</code> 判斷 HTTP 狀態碼<br>- 在錯誤時觸發 <code>onerror</code> 事件</td>
                </tr>
                <tr>
                  <td><strong>Response類型</strong></td>
                  <td>- 支持多種Response類型，如 <code>response.json()</code>、<code>response.text()</code>、<code>response.blob()</code>、<code>response.arrayBuffer()</code>、<code>response.formData()</code></td>
                  <td>- Response存儲在 <code>responseText</code>（字符串）和 <code>responseXML</code>（XML 文檔）中</td>
                </tr>
                <tr>
                  <td><strong>Request header設置</strong></td>
                  <td>- 使用 <code>Headers</code> 物件設置Request header<br>- 某些頭部不可修改（如 <code>Referer</code>、<code>User-Agent</code>）</td>
                  <td>- 使用 <code>setRequestHeader()</code> 方法設置Request header<br>- 可以設置更多自定義頭部</td>
                </tr>
                <tr>
                  <td><strong>跨域請求（CORS）</strong></td>
                  <td>- 默認採用 CORS<br>- 支持跨域請求，但需要伺服器允許</td>
                  <td>- 需要額外設定才能進行跨域請求<br>- 可能受到更多限制</td>
                </tr>
                <tr>
                  <td><strong>流式處理</strong></td>
                  <td>- 支持流式Response（Streaming）<br>- 可逐步處理大型數據</td>
                  <td>- 不支持流式Response<br>- 必須在Response完全接收後才能處理</td>
                </tr>
                <tr>
                  <td><strong>請求取消（Abort）</strong></td>
                  <td>- 支持使用 <code>AbortController</code> 取消請求</td>
                  <td>- 可使用 <code>xhr.abort()</code> 方法取消請求</td>
                </tr>
                <tr>
                  <td><strong>超時設置</strong></td>
                  <td>- 不直接支持超時設置<br>- 需要使用 <code>Promise.race()</code> 實現超時控制</td>
                  <td>- 支持 <code>xhr.timeout</code> 屬性設置超時時間<br>- 可監聽 <code>ontimeout</code> 事件</td>
                </tr>
                <tr>
                  <td><strong>上傳文件</strong></td>
                  <td>- 支持通過 <code>fetch</code> 上傳文件<br>- 但無法監聽上傳進度</td>
                  <td>- 支持上傳文件<br>- 可通過 <code>xhr.upload.onprogress</code> 監聽上傳進度</td>
                </tr>
                <tr>
                  <td><strong>自動發送 Cookie</strong></td>
                  <td>- 默認不發送 Cookie<br>- 需要設置 <code>credentials</code> 選項<br>- <code>credentials: 'same-origin'</code> 或 <code>credentials: 'include'</code></td>
                  <td>- 默認會發送並接收 Cookie<br>- 可通過 <code>withCredentials</code> 屬性控制</td>
                </tr>
                <tr>
                  <td><strong>HTTP Response碼處理</strong></td>
                  <td>- 需要手動檢查 <code>response.ok</code> 或 <code>response.status</code> 來判斷是否成功</td>
                  <td>- 可直接通過 <code>xhr.status</code> 判斷請求是否成功</td>
                </tr>
                <tr>
                  <td><strong>原生支援度</strong></td>
                  <td>- 現代瀏覽器原生支持<br>- IE 不支持 Fetch API，需要使用 polyfill</td>
                  <td>- 所有主流瀏覽器均支持，包括較舊版本的 IE</td>
                </tr>
                <tr>
                  <td><strong>調試和追蹤</strong></td>
                  <td>- 調試較為困難，錯誤信息可能不夠詳細</td>
                  <td>- 調試較為方便，可在開發者工具中查看請求詳細信息</td>
                </tr>
                <tr>
                  <td><strong>HTTP 改寫或重導向</strong></td>
                  <td>- <code>fetch</code> 會自動處理 HTTP 重導向<br>- 可設置 <code>redirect</code> 選項控制</td>
                  <td>- 需要手動處理重導向，較為麻煩</td>
                </tr>
                <tr>
                  <td><strong>安全性</strong></td>
                  <td>- 遵循嚴格的 CORS 政策<br>- 某些頭部不可修改，增強安全性</td>
                  <td>- 可能存在被利用的風險，需要謹慎處理</td>
                </tr>
                <tr>
                  <td><strong>使用場景</strong></td>
                  <td>- 適合現代化的應用開發<br>- 需要處理 Promise 的情況</td>
                  <td>- 適合需要兼容舊瀏覽器<br>- 需要監聽進度或同步請求</td>
                </tr>
                <tr>
                  <td><strong>API 靈活性</strong></td>
                  <td>- API 簡潔但某些功能有限<br>- 需要結合其他 API（如 Streams、AbortController）實現高級功能</td>
                  <td>- API 功能全面<br>- 支持更多細節控制和設定</td>
                </tr>
              </tbody>
            </table>
            
          </section>
        </section>

        <section id="_promise與非同步處理">
          <h2>Promise 與非同步處理</h2>
          <section id="_promise">
            <h3>Promise</h3>

            <p>Promise 照字面意思是「承諾」，它代表的是一個非同步操作在未來某個時刻會返回數據或錯誤給調用者。Promise 只會在操作成功（或失敗）時返回一次結果。根據 MDN 文件的定義，Promise 用來表示一個非同步操作的最終完成（resolved）或失敗（rejected）及其結果值。</p>

            <h4 id="_promise的狀態">Promise 的狀態</h4>
            <ul>
              <li><strong>pending</strong>：初始狀態，表示 Promise 尚未完成。</li>
              <li><strong>fulfilled</strong>：表示操作成功，並且返回了結果（執行了 <code>resolve()</code>）。</li>
              <li><strong>rejected</strong>：表示操作失敗，並且返回了錯誤（執行了 <code>reject()</code>）。</li>
            </ul>
            <p>
              當 Promise 狀態從 <strong>pending</strong> 變為 <strong>fulfilled</strong> 或 <strong>rejected</strong> 後，其狀態就會保持不變，無法再次改變。
            </p>

            <h4 id="_基本結構">Promise 基本結構</h4>
            <p>Promise 的基本結構如下，它接受兩個回調函數作為參數：<code>resolve</code>（操作成功時調用）和 <code>reject</code>（操作失敗時調用）：</p>
            <pre class="prettyprint">
let promise = new Promise((resolve, reject) => {
  let success = true;

  if (success) {
    resolve('操作成功');
  } else {
    reject('操作失敗');
  }
});

promise.then(result => {
  console.log(result);  // 輸出 '操作成功'
})
.catch(error => {
  console.error(error);  // 輸出 '操作失敗'
});
            </pre>

            <h4 id="_鏈式結構">Promise 鏈式結構</h4>
            <p>
              Promise 的一個強大功能是它可以鏈式調用，這讓我們能夠依次處理多個異步操作。每個 <code>.then()</code> 返回一個新的 Promise，允許我們進一步進行處理。
            </p>
            <pre class="prettyprint">
fetch("https://openlibrary.org/search.json?q=the+lord+of+the+rings")
.then(response => {
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  return response.json();           // 返回解析後的 JSON 數據
})
.then(data => {
  console.log(data);                // 處理解析後的數據
})
.catch(error => {
  console.error(error);             // 捕獲異常，處理錯誤
});
            </pre>

            <h4 id="_靈活應用">Promise 的靈活應用</h4>
            <p>
              Promise 還提供了多種強大的方法來處理多個異步操作，如 <code>Promise.all()</code>, <code>Promise.allSettled()</code>, <code>Promise.race()</code>, 和 <code>Promise.any()</code>。每個方法都有不同的用途和行為，適合不同的異步場景。
            </p>

            <h4 id="_promise_all">1. <code>Promise.all()</code></h4>
            <p>

              <code>Promise.all()</code> 並行執行所有傳入的
              Promise，這對提高效率非常重要，尤其是當你需要並行執行多個耗時的操作時（如多個網路請求）。

            </p>

            <h4 id="_promise_all_使用範例">Promise.all() 實際範例</h4>
            <pre class="prettyprint">
const fetchGatsby = fetch("https://openlibrary.org/search.json?q=the+great+gatsby")
  .then(response => response.json());

const fetchLordOfTheRings = fetch("https://openlibrary.org/search.json?q=the+lord+of+the+ring")
  .then(response => response.json());

const fetchPrideAndPrejudice = fetch("https://openlibrary.org/search.json?q=pride+and+prejudice")
  .then(response => response.json());

Promise.all([fetchGatsby, fetchLordOfTheRings, fetchPrideAndPrejudice])
  .then(([gatsbyData, lotrData, prideData]) => {
    console.log('The Great Gatsby:', gatsbyData);
    console.log('The Lord of the Rings:', lotrData);
    console.log('Pride and Prejudice:', prideData);
  })
  .catch(error => {
    console.error('Error fetching data:', error);
  });
            </pre>

            <h4 id="_promise_allSettled">2. <code>Promise.allSettled()</code></h4>
            <p>
              <strong>Promise.allSettled()</strong> 會等待所有的 Promise 都已完成，不論它們是成功還是失敗。這對於你希望在所有操作都結束後再進行處理，而不因為某一個操作的失敗中斷整個流程時非常有用。
            </p>

            <h4 id="_promise_allSettled_使用範例">Promise.allSettled() 實際範例</h4>
            <pre class="prettyprint">
Promise.allSettled([fetchGatsby, fetchLordOfTheRings, fetchPrideAndPrejudice])
  .then(results => {
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('成功:', result.value);
      } else {
        console.log('失敗:', result.reason);
      }
    });
  });
            </pre>

            <h4 id="_promise_race">3. <code>Promise.race()</code></h4>
            <p>
              <strong>Promise.race()</strong> 返回第一個解決或拒絕的 Promise。無論是哪個 Promise 最先完成（成功或失敗），它都會將結果作為新的 Promise 返回。如果你只需要第一個完成的結果，這是一個非常有用的工具。
            </p>

            <h4>Promise.race() 實際範例</h4>
            <pre class="prettyprint">
const fetchSlower = new Promise(resolve => setTimeout(resolve, 2000, '慢的'));
const fetchFaster = new Promise(resolve => setTimeout(resolve, 1000, '快的'));

Promise.race([fetchSlower, fetchFaster])
  .then(result => {
    console.log(result);  // 只返回 '快的'
  })
  .catch(error => {
    console.error(error);
  });
            </pre>

            <h4 id="_promise_any">4. <code>Promise.any()</code></h4>
            <p>
              <strong>Promise.any()</strong> 會返回第一個成功的 Promise，並忽略所有失敗的 Promise。如果所有的 Promise 都被拒絕，它會返回一個拒絕的 Promise。這對於你只關心第一個成功結果，而不在意失敗時非常有用。
            </p>

            <h4 id="_promise_any_使用範例">Promise.any() 實際範例</h4>
            <pre class="prettyprint">
const failedFetch1 = new Promise((_, reject) => setTimeout(reject, 1000, '失敗 1'));
const failedFetch2 = new Promise((_, reject) => setTimeout(reject, 1500, '失敗 2'));
const successfulFetch = new Promise(resolve => setTimeout(resolve, 500, '成功'));

Promise.any([failedFetch1, failedFetch2, successfulFetch])
  .then(result => {
    console.log(result);  // 返回 '成功'
  })
  .catch(error => {
    console.error('所有 Promise 都失敗:', error);
  });
            </pre>
          </section>

          <h3 id="_promise_方法比較">Promise 方法比較</h3>
          <table>
            <thead>
              <tr>
                <th>方法</th>
                <th>功能</th>
                <th>成功處理</th>
                <th>失敗處理</th>
                <th>適用場景</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>Promise.all()</code></td>
                <td>並行執行多個 Promise，等待全部成功</td>
                <td>返回一個包含所有結果的陣列</td>
                <td>當任一 Promise 失敗，返回失敗的 Promise</td>
                <td>希望所有異步操作都成功，任何失敗都會中斷流程時</td>
              </tr>
              <tr>
                <td><code>Promise.allSettled()</code></td>
                <td>並行執行多個 Promise，等待全部完成</td>
                <td>返回每個 Promise 的狀態和結果</td>
                <td>不會中斷，所有 Promise 結果都會被返回</td>
                <td>需要獲得每個 Promise 的完整結果，不關心成功或失敗時</td>
              </tr>
              <tr>
                <td><code>Promise.race()</code></td>
                <td>返回第一個完成的 Promise</td>
                <td>最先完成的 Promise 的結果會被返回</td>
                <td>最先失敗的 Promise 的錯誤會被返回</td>
                <td>只需要最先完成的結果，無論成功還是失敗</td>
              </tr>
              <tr>
                <td><code>Promise.any()</code></td>
                <td>返回第一個成功的 Promise</td>
                <td>最先成功的 Promise 的結果會被返回</td>
                <td>只有當所有 Promise 都失敗時才返回一個拒絕的 Promise</td>
                <td>只關心有一個成功結果，不在意失敗的 Promise</td>
              </tr>
            </tbody>
          </table>
        </section>

      </main>
    </div>

    <footer>
      <p></p>
    </footer>
    <div id="footer">
      <div id="footer-text" class="pageclick">
        <a href="./function2.html" class="pageclick left">上一頁</a>
        <a href="./index.html" class="pageclick center">回目錄</a>
        <a href="./newmypart.html" class="pageclick right">下一頁</a>
      </div>
    </div>
  </body>
</html>
