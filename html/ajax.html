<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript 同步與非同步</title>
    <script src="../js/run_pprettify.js"></script>
    <link rel="stylesheet" href="../css/style.css" />
    <link rel="stylesheet" href="../css/pretty.css" />
    <style>
      #container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #header,
      main {
        width: 80%;
        max-width: 1200px;
      }
      #header {
        text-align: left;
      }
      main {
        margin-top: 20px;
      }
      #toc ul {
        list-style-type: disc;
        padding-left: 20px;
      }
      #toc li {
        margin: 5px 0;
      }
      #toc a {
        text-decoration: none;
        color: #1a73e8;
      }
      #toc a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="header">
        <header>
          <h1>JavaScript 同步與非同步</h1>
        </header>
        <nav id="toc" class="toc">
          <div id="toctitle">目錄</div>
          <ul class="sectlevel1">
            <li>
              <a href="#_同步與非同步概念">同步與非同步概念</a>
              <ul>
                <li><a href="#_同步是什麼">同步是什麼？</a></li>
                <li><a href="#_非同步是什麼">非同步是什麼？</a></li>
                <li>
                  <a href="#_為什麼Javascript可以非同步"
                    >為什麼 JavaScript 可以非同步？</a
                  >
                </li>
                <li><a href="#_為什麼需要非同步">為什麼需要非同步</a></li>
              </ul>
            </li>
            <li>
              <a href="#_ajax與數據請求">AJAX 與數據請求</a>
              <ul>
                <li><a href="#_什麼是_ajax">什麼是 AJAX?</a></li>
                <li><a href="#_xmlhttprequest">XMLHttpRequest</a></li>
                <li><a href="#_fetch">Fetch</a></li>
                <li>
                  <a href="#_fetch_xhr_comparison">XMLHttpRequest vs. Fetch</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#_promise與異步處理">Promise 與異步處理</a>
              <ul>
                <li>
                  <a href="#_promise">Promise</a>
                  <ul>
                    <li><a href="#_promise的狀態">Promise 的狀態</a></li>
                    <li><a href="#_基本結構">基本結構</a></li>
                    <li><a href="#_鏈式結構">鏈式結構</a></li>
                    <li><a href="#_靈活應用">Promise 的靈活應用</a></li>
                    <li><a href="#_promise_all">Promise.all()</a></li>
                    <li><a href="#_promise_all_使用範例">Promise.all() 實際範例</a></li>
                    <li><a href="#_promise_allSettled">Promise.allSettled()</a></li>
                    <li><a href="#_promise_allSettled_使用範例">Promise.allSettled() 實際範例</a></li>
                    <li><a href="#_promise_race">Promise.race()</a></li>
                    <li><a href="#_promise_race_使用範例">Promise.race() 實際範例</a></li>
                    <li><a href="#_promise_any">Promise.any()</a></li>
                    <li><a href="#_promise_any_使用範例">Promise.any() 實際範例</a></li>
                  </ul>
                </li>
                <li>
                  <a href="#_promise_方法比較">Promise 方法比較</a>
                </li>
              </ul>
            </li>
          </ul>
        </nav>
      </div>

      <main>
        <section id="_同步與非同步概念">
          <h2>同步與非同步概念</h2>

          <section id="_同步是什麼">
            <h3>同步是什麼？</h3>
            <p>「同步」指的是一次只能做一件事情。</p>
            <p>
              JavaScript 是「單執行緒 (Single-Thread)」語言，這意味著它一次只能執行一個任務。所有操作都會按順序執行，這是同步的概念。
            </p>
            <pre class="prettyprint">
        // Synchronous code example
        console.log("Start");

        console.log("Performing a synchronous task");

        console.log("End");
            </pre>
          </section>

          <section id="_非同步是什麼">
            <h3>非同步是什麼？</h3>
            <p>
              非同步允許多個任務並行進行，無需等待前一個任務完成。非同步處理讓 JavaScript 可以在不阻塞主線程的情況下處理耗時操作，比如網絡請求或定時器。
            </p>
            <pre class="prettyprint">
        console.log("hello");
        setTimeout(function() {
          console.log("End");
        }, 1000);

        for(let i = 0; i < 4; i++) {
            console.log(i);
        }
            </pre>
            <p>
              在這個例子中，<code>setTimeout</code> 是一個非同步操作，並不會阻塞 JavaScript 執行其他代碼。即使我們指定它在 1000 毫秒後執行，但 JavaScript 會繼續執行後續的 <code>for</code> 迴圈，而不必等待 <code>setTimeout</code> 完成。
            </p>
          </section>

          <section id="_為什麼需要非同步">
            <h3>為什麼需要非同步？什麼時候會用到？</h3>
            <h4>Blocking</h4>
            <p>阻塞（blocking）是指程式在執行某個操作時，必須等待該操作完成才能繼續執行後續的代碼。這樣的情況可能會導致頁面無法響應，特別是在進行以下操作時：</p>
            <ul>
              <li><strong>向 API 發送請求：</strong>若是同步處理，JavaScript 在等待 API 回應時，頁面會被鎖住，什麼操作都無法進行。</li>
              <li><strong>setTimeout：</strong>定時器如果是同步的，則必須等待時間結束，其他代碼無法執行。</li>
              <li><strong>DOM 操作：</strong>若是同步處理，則在操作 DOM 的過程中，整個頁面無法進行其他交互。</li>
            </ul>
            <p>
              為了避免這些阻塞問題，JavaScript 引入了非同步機制，讓長時間執行的任務可以在後台進行，並在完成後通知主執行線程。
            </p>
            <h4 style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
              <a href="./blocking-demo.html" style="color: #007bff; text-decoration: none; font-weight: bold;"">點擊這裡操作頁面以了解阻塞概念</a>
            </h4>
          </section>

          <section id="_為什麼Javascript可以非同步">
            <h3>為什麼 JavaScript 可以非同步？</h3>
            <p>
              雖然 JavaScript 是單執行緒語言，但它可以透過與瀏覽器的 Web API 進行互動，實現非同步處理。這樣，JavaScript 本身依然是同步的，但透過 Web API 它能夠並行處理多個任務，而不會阻塞主線程。
            </p>
            <p>
              這些 Web API（例如：<code>setTimeout</code>、<code>XMLHttpRequest</code>、<code>fetch</code>）允許瀏覽器代為處理異步操作，並在任務完成後將結果傳回 JavaScript 引擎。
            </p>

            <h4>JavaScript 的執行機制</h4>
            <p>
              為了理解 JavaScript 是如何處理非同步操作的，我們需要了解它的執行機制，主要包括以下幾個部分：
            </p>

            <ul>
              <li><strong>Call Stack (調用堆疊)：</strong>JavaScript 執行同步代碼時，會依次將函數推入調用堆疊，並從堆疊中彈出執行完成的函數。</li>
              <li><strong>Web API：</strong>Web API 是由瀏覽器提供的，專門用來處理異步操作。當 JavaScript 遇到像 <code>setTimeout</code> 或 <code>fetch</code> 這樣的異步操作時，會將它們委託給 Web API 處理，並繼續執行其他同步代碼。</li>
              <li><strong>Callback Queue (回調隊列)：</strong>當 Web API 完成異步操作後，會將回調函數放入回調隊列，等待主線程空閒時執行。</li>
              <li><strong>Microtask Queue (微任務隊列)：</strong>這是專門用來處理更高優先級的任務，比如 <code>Promise</code> 的回調。微任務在每次事件循環結束後會立即執行。</li>
              <li><strong>Macrotask Queue (宏任務隊列)：</strong>宏任務包括 <code>setTimeout</code> 和 <code>setInterval</code> 等異步操作。這些任務的回調會在微任務執行完畢後執行。</li>
            </ul>

            <h4>事件循環 (Event Loop)</h4>
            <p>
              JavaScript 使用「事件循環 (Event Loop)」來協調這些任務。事件循環會不斷檢查調用堆疊是否為空，如果為空，就會從回調隊列中取出任務執行，從而實現非同步操作。
            </p>

            <h4>完整執行流程</h4>
            <p>完整的非同步執行流程如下：</p>
            <ol>
              <li>JavaScript 將同步代碼推入 Call Stack 執行。</li>
              <li>當遇到異步操作時，將其交給 Web API 處理，並繼續執行其他代碼。</li>
              <li>Web API 完成任務後，將回調函數放入 Callback Queue 或 Microtask Queue 中。</li>
              <li>事件循環檢查 Call Stack 是否空閒，若空閒則依次處理回調隊列中的回調。</li>
              <li>Microtask Queue 會優先於 Macrotask Queue 執行。</li>
            </ol>

            <h4>例子展示非同步運作</h4>
            <pre class="prettyprint">
        console.log("Start");

        setTimeout(() => {
          console.log("Timeout callback");
        }, 1000);

        Promise.resolve().then(() => {
          console.log("Promise callback");
        });

        console.log("End");
            </pre>

            <p>
              這段代碼會輸出：
            </p>
            <ul>
              <li>Start</li>
              <li>End</li>
              <li>Promise callback</li>
              <li>Timeout callback</li>
            </ul>
            <p>原因是 Promise 的回調會進入微任務隊列（Microtask Queue），而 <code>setTimeout</code> 的回調則進入宏任務隊列（Macrotask Queue）。微任務會優先執行，因此 Promise 的回調會在 <code>setTimeout</code> 之前執行。</p>

            <h4 style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center;">
              <a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" style="color: #007bff; text-decoration: none; font-weight: bold;">🎥 點擊這裡查看完整的事件循環可視化演示</a>
            </h4>
          </section>
        </section>


      <section>
        <section id="_ajax與數據請求">
          <h2>AJAX 與數據請求</h2>
          <section id="_什麼是_ajax">
            <h3>什麼是 AJAX?</h3>
            <p>
              AJAX（Asynchronous
              <a
                href="https://developer.mozilla.org/zh-TW/docs/Glossary/JavaScript"
                >JavaScript</a
              >
              And
              <a href="https://developer.mozilla.org/en-US/docs/Glossary/XML"
                >XML</a
              >，非同步 JavaScript 與 XML）是結合了
              <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/HTML"
                >HTML</a
              >、<a href="https://developer.mozilla.org/zh-TW/docs/Glossary/CSS"
                >CSS</a
              >、JavaScript、<a
                href="https://developer.mozilla.org/zh-TW/docs/Glossary/DOM"
                >DOM</a
              >、還有
              <code>XMLHttpRequest</code> 物件，以建立更複雜的網頁應用。AJAX
              允許網頁只更新所需的部分，而無需重新載入整個頁面。雖然名字中有
              XML，但它也可以用現今廣泛使用的 JSON 及其他資料類型（如 HTML, Form
              Data, Binary Data, Blob, ArrayBuffer）進行資料交換。
            </p>
          </section>

          <section id="_xmlhttprequest">
            <h3>XMLHttpRequest</h3>
            <p>
              XMLHttpRequest 是 JavaScript 中的物件，允許網頁向伺服器發送 HTTP
              或 HTTPS
              請求，並在不重新載入整個網頁的情況下接收回應資料。這項技術是實現
              AJAX 的重要組成部分，能讓網頁內容動態更新。雖然現在常用 fetch()
              技術，但 XMLHttpRequest 在某些較舊的項目中仍然被廣泛使用。
            </p>

            <h4>XMLHttpRequest 基本概念</h4>
            <h5>1. 建立 XMLHttpRequest 物件</h5>
            <pre class="prettyprint">let xhr = new XMLHttpRequest();</pre>

            <h5>2. 打開請求 (open)</h5>
            <pre class="prettyprint">
xhr.open('GET', 'https://api.example.com/data', true);</pre
            >
            <p>
              • 第一個參數是 HTTP 方法（如 GET 或 POST）。<br />
              • 第二個參數是目標 URL。<br />
              • 第三個參數是布林值，表示是否以非同步方式發送請求。通常使用 true
              表示非同步。
            </p>

            <h5>3. 發送請求 (send)</h5>
            <pre class="prettyprint">xhr.send();</pre>
            <p>如果是 POST 請求，可以將資料以字串格式傳入 send() 中：</p>
            <pre class="prettyprint">
let data = JSON.stringify({ name: "Oscar", age: 24 });
xhr.send(data);</pre
            >

            <h5>4. 處理回應 (response)</h5>
            <p>
              可以透過 <code>onreadystatechange</code> 或
              <code>onload</code> 監聽請求的狀態變化並處理回應：
            </p>

            <pre class="prettyprint">
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText); // 輸出伺服器回應的資料
    }
};</pre
            >

            <p><strong>readyState 狀態值：</strong></p>
            <ul>
              <li>0: UNSENT – 請求尚未打開。</li>
              <li>1: OPENED – 請求已打開，但尚未發送。</li>
              <li>2: HEADERS_RECEIVED – 已收到伺服器回應標頭。</li>
              <li>3: LOADING – 請求正在處理，回應的資料正在接收。</li>
              <li>4: DONE – 請求已完成，回應可用。</li>
            </ul>

            <pre class="prettyprint">
xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
        console.log(xhr.responseText); // 處理回應資料
    } else {
        console.error('請求失敗');
    }
};</pre
            >
          </section>

          <section id="_fetch">
            <h3>Fetch</h3>
            <h4>什麼是 Fetch？</h4>
            <p>
              <strong>Fetch API</strong> 是
              <strong>XMLHttpRequest</strong> 的現代替代品。它使用
              <strong>Promise</strong> 來處理非同步操作，設計更加靈活且簡潔。
            </p>
            <pre class="prettyprint">
fetch('https://api.example.com/products')
  .then(response => {
    if (!response.ok) {
      throw new Error('網路回應有誤：' + response.statusText);
    }
    return response.json();  // 解析 JSON 資料
  })
  .then(products => {
    console.log(products);  // 處理並顯示產品
  })
  .catch(error => {
    console.error('Fetch 操作中出現問題：', error);
  });</pre
            >

            <h4>使用 Fetch 發送 POST 請求</h4>
            <p>假設用戶將產品加入購物車，可以使用 Fetch 發送 POST 請求：</p>
            <pre class="prettyprint">
fetch('https://api.example.com/cart', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    productId: 12345,
    quantity: 1
  })
})
  .then(response => response.json())
  .then(data => console.log('產品已加入購物車：', data))
  .catch(error => console.error('加入購物車時發生錯誤：', error));</pre
            >
          </section>

          <section id="_fetch_xhr_comparison">
            <h3>XMLHttpRequest vs. Fetch</h3>
            <h4>XMLHttpRequest 範例：</h4>
            <pre class="prettyprint">
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onload = function() {
  if (xhr.status >= 200 && xhr.status < 300) {
    var data = JSON.parse(xhr.responseText);
    console.log(data);
  } else {
    console.error('Error:', xhr.statusText);
  }
};
xhr.onerror = function() {
  console.error('Request failed');
};
xhr.send();
            </pre>

            <h4>Fetch 範例：</h4>
            <pre class="prettyprint">
fetch('https://api.example.com/data')
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));</pre
            >
          </section>
        </section>

        <section id="_promise與異步處理">
          <h2>Promise 與異步處理</h2>
          <section id="_promise">
            <h3>Promise</h3>
            <p>
              Promise 照字面意思是「承諾」，它代表一個異步操作在未來某個時刻會返回數據或錯誤給調用者。Promise 只會在操作成功（<code>resolved</code>）或失敗（<code>rejected</code>）時返回一次結果。Promise 是 JavaScript 中處理異步操作的標準方式之一，用來取代繁瑣的回調函數（Callback Functions），提升代碼的可讀性和維護性。
            </p>

            <h4 id="_promise的狀態">Promise 的狀態</h4>
            <ul>
              <li><strong>pending</strong>：初始狀態，表示 Promise 尚未完成。</li>
              <li><strong>fulfilled</strong>：表示操作成功，並且返回了結果（執行了 <code>resolve()</code>）。</li>
              <li><strong>rejected</strong>：表示操作失敗，並且返回了錯誤（執行了 <code>reject()</code>）。</li>
            </ul>
            <p>
              當 Promise 狀態從 <strong>pending</strong> 變為 <strong>fulfilled</strong> 或 <strong>rejected</strong> 後，其狀態就會保持不變，無法再次改變。
            </p>

            <h4 id="_基本結構">Promise 基本結構</h4>
            <p>Promise 的基本結構如下，它接受兩個回調函數作為參數：<code>resolve</code>（操作成功時調用）和 <code>reject</code>（操作失敗時調用）：</p>
            <pre class="prettyprint">
let promise = new Promise((resolve, reject) => {
  let success = true;

  if (success) {
    resolve('操作成功');
  } else {
    reject('操作失敗');
  }
});

promise.then(result => {
  console.log(result);  // 輸出 '操作成功'
})
.catch(error => {
  console.error(error);  // 輸出 '操作失敗'
});
            </pre>

            <h4 id="_鏈式結構">Promise 鏈式結構</h4>
            <p>
              Promise 的一個強大功能是它可以鏈式調用，這讓我們能夠依次處理多個異步操作。每個 <code>.then()</code> 返回一個新的 Promise，允許我們進一步進行處理。
            </p>
            <pre class="prettyprint">
fetch("https://openlibrary.org/search.json?q=the+lord+of+the+rings")
.then(response => {
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  return response.json();           // 返回解析後的 JSON 數據
})
.then(data => {
  console.log(data);                // 處理解析後的數據
})
.catch(error => {
  console.error(error);             // 捕獲異常，處理錯誤
});
            </pre>

            <h4 id="_靈活應用">Promise 的靈活應用</h4>
            <p>
              Promise 還提供了多種強大的方法來處理多個異步操作，如 <code>Promise.all()</code>, <code>Promise.allSettled()</code>, <code>Promise.race()</code>, 和 <code>Promise.any()</code>。每個方法都有不同的用途和行為，適合不同的異步場景。
            </p>

            <h4 id="_promise_all">1. <code>Promise.all()</code></h4>
            <p>
              <strong>Promise.all()</strong> 接受一個 Promise 的數組，並且會並行執行這些 Promise。只有當所有 Promise 都成功時，才返回一個新的 Promise，這個 Promise 的結果是一個包含所有結果的數組。如果其中任一 Promise 被拒絕，<code>Promise.all()</code> 會立即返回一個被拒絕的 Promise，並將錯誤傳遞到 <code>.catch()</code> 中。
            </p>

            <h4 id="_promise_all_使用範例">Promise.all() 實際範例</h4>
            <pre class="prettyprint">
const fetchGatsby = fetch("https://openlibrary.org/search.json?q=the+great+gatsby")
  .then(response => response.json());

const fetchLordOfTheRings = fetch("https://openlibrary.org/search.json?q=the+lord+of+the+ring")
  .then(response => response.json());

const fetchPrideAndPrejudice = fetch("https://openlibrary.org/search.json?q=pride+and+prejudice")
  .then(response => response.json());

Promise.all([fetchGatsby, fetchLordOfTheRings, fetchPrideAndPrejudice])
  .then(([gatsbyData, lotrData, prideData]) => {
    console.log('The Great Gatsby:', gatsbyData);
    console.log('The Lord of the Rings:', lotrData);
    console.log('Pride and Prejudice:', prideData);
  })
  .catch(error => {
    console.error('Error fetching data:', error);
  });
            </pre>

            <h4 id="_promise_allSettled">2. <code>Promise.allSettled()</code></h4>
            <p>
              <strong>Promise.allSettled()</strong> 會等待所有的 Promise 都已完成，不論它們是成功還是失敗。這對於你希望在所有操作都結束後再進行處理，而不因為某一個操作的失敗中斷整個流程時非常有用。
            </p>

            <h4 id="_promise_allSettled_使用範例">Promise.allSettled() 實際範例</h4>
            <pre class="prettyprint">
Promise.allSettled([fetchGatsby, fetchLordOfTheRings, fetchPrideAndPrejudice])
  .then(results => {
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('成功:', result.value);
      } else {
        console.log('失敗:', result.reason);
      }
    });
  });
            </pre>

            <h4 id="_promise_race">3. <code>Promise.race()</code></h4>
            <p>
              <strong>Promise.race()</strong> 返回第一個解決或拒絕的 Promise。無論是哪個 Promise 最先完成（成功或失敗），它都會將結果作為新的 Promise 返回。如果你只需要第一個完成的結果，這是一個非常有用的工具。
            </p>

            <h4>Promise.race() 實際範例</h4>
            <pre class="prettyprint">
const fetchSlower = new Promise(resolve => setTimeout(resolve, 2000, '慢的'));
const fetchFaster = new Promise(resolve => setTimeout(resolve, 1000, '快的'));

Promise.race([fetchSlower, fetchFaster])
  .then(result => {
    console.log(result);  // 只返回 '快的'
  })
  .catch(error => {
    console.error(error);
  });
            </pre>

            <h4 id="_promise_any">4. <code>Promise.any()</code></h4>
            <p>
              <strong>Promise.any()</strong> 會返回第一個成功的 Promise，並忽略所有失敗的 Promise。如果所有的 Promise 都被拒絕，它會返回一個拒絕的 Promise。這對於你只關心第一個成功結果，而不在意失敗時非常有用。
            </p>

            <h4 id="_promise_any_使用範例">Promise.any() 實際範例</h4>
            <pre class="prettyprint">
const failedFetch1 = new Promise((_, reject) => setTimeout(reject, 1000, '失敗 1'));
const failedFetch2 = new Promise((_, reject) => setTimeout(reject, 1500, '失敗 2'));
const successfulFetch = new Promise(resolve => setTimeout(resolve, 500, '成功'));

Promise.any([failedFetch1, failedFetch2, successfulFetch])
  .then(result => {
    console.log(result);  // 返回 '成功'
  })
  .catch(error => {
    console.error('所有 Promise 都失敗:', error);
  });
            </pre>
          </section>

          <h3 id="_promise_方法比較">Promise 方法比較</h3>
          <table>
            <thead>
              <tr>
                <th>方法</th>
                <th>功能</th>
                <th>成功處理</th>
                <th>失敗處理</th>
                <th>適用場景</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>Promise.all()</code></td>
                <td>並行執行多個 Promise，等待全部成功</td>
                <td>返回一個包含所有結果的陣列</td>
                <td>當任一 Promise 失敗，返回失敗的 Promise</td>
                <td>希望所有異步操作都成功，任何失敗都會中斷流程時</td>
              </tr>
              <tr>
                <td><code>Promise.allSettled()</code></td>
                <td>並行執行多個 Promise，等待全部完成</td>
                <td>返回每個 Promise 的狀態和結果</td>
                <td>不會中斷，所有 Promise 結果都會被返回</td>
                <td>需要獲得每個 Promise 的完整結果，不關心成功或失敗時</td>
              </tr>
              <tr>
                <td><code>Promise.race()</code></td>
                <td>返回第一個完成的 Promise</td>
                <td>最先完成的 Promise 的結果會被返回</td>
                <td>最先失敗的 Promise 的錯誤會被返回</td>
                <td>只需要最先完成的結果，無論成功還是失敗</td>
              </tr>
              <tr>
                <td><code>Promise.any()</code></td>
                <td>返回第一個成功的 Promise</td>
                <td>最先成功的 Promise 的結果會被返回</td>
                <td>只有當所有 Promise 都失敗時才返回一個拒絕的 Promise</td>
                <td>只關心有一個成功結果，不在意失敗的 Promise</td>
              </tr>
            </tbody>
          </table>
        </section>

      </main>
    </div>

    <footer>
      <p></p>
    </footer>
    <div id="footer">
      <div id="footer-text" class="pageclick">
        <a href="./function2.html" class="pageclick left">上一頁</a>
        <a href="./index.html" class="pageclick center">回目錄</a>
        <a href="./newmypart.html" class="pageclick right">下一頁</a>
      </div>
    </div>
  </body>
</html>
