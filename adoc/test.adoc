=== 具名函式/匿名函式
=== Automatic Semicolon Insertion, ASI
=== 原始型別/物件型別
=== 顯性轉換/隱性轉換
=== 型別比較

== 具名函式/匿名函式

=== 1. 具名函式（Named Functions）

具名函式是指在定義函式時給它一個名稱。這樣可以方便在程式中調用這個函式。具名函式的主要優點是可以清晰地表達函式的目的，並且可以在調試時提供堆疊跟蹤信息。

==== 定義：

[source,javascript]
----
function myFunction() {
console.log("這是一個具名函式");
}
----

==== 使用：

[source,javascript]
----
myFunction();  // 輸出：這是一個具名函式
----

通常具名函式用於有個相同的功能需要被重複被使用的，或是想將複雜的邏輯拆解的情況，
比如現在要寫一個點擊button後，根據input內的值回傳對應的結果。
在沒有使用具名方法的情況，若之後有越來越多的 button，程式會越來越難維護。

[source,javascript]
----
//  button1
document.getElementById("button1").addEventListener("click",function() {
    let value = document.getElementById("input2").value;
    console.log(value);
})

// button2
document.getElementById("button2").addEventListener("click",function() {
    let value = document.getElementById("input2").value;
    console.log(value);
})
----


這時候將重複的程式碼內容取出寫成方法，可以看到程式碼變得比較簡單易懂一些，就
算今天有5個button要監聽，也比沒有用的情況好理解一點。重點是未來要修改時，
只需要修改 function 本身就可以一次性修改所有 button 的監聽事件

[source,javascript]
----
/**
 * 添加監聽，並印出 input 的 value
 * @param button 要監聽的button id
 * @param input 要讀取的input id
 */
function getValueAndConsole(button, input) {
    document.getElementById(button).addEventListener("click",function() {
        let value = document.getElementById(input).value;
        console.log(value);
    })
}

getValueAndConsole("button1", "input1");
getValueAndConsole("button2", "input2");
----

==== 優點：

* *可讀性*：具名函式通常更具可讀性，因為名稱可以描述函式的功能。
* *模組化*： 可以讓程式更易於拆分為可重用的模組，每個函式都有明確的名稱和功能，促進代碼的組織性和維護性
* *堆疊跟蹤*：在發生錯誤時，堆疊跟蹤會顯示具名函式的名稱，便於調試。


=== 2. 匿名函式（Anonymous Functions）

匿名函式是指在定義時沒有給它起名稱的函式。通常，匿名函式用於一次性使用的場景，例如作為回調函式或在立即執行函式表達式（IIFE）中使用。

==== 定義：

[source,javascript]
----
const myAnonymousFunction = function() {
console.log("這是一個匿名函式");
};
----

==== 使用：

[source,javascript]
----
myAnonymousFunction();  // 輸出：這是一個匿名函式
----

==== 在回調中的使用：

[source,javascript]
----
setTimeout(function() {
console.log("這是一個匿名回調函式");
}, 1000);
----

==== 優點：

* *靈活性*：匿名函式可以在需要的地方直接使用，尤其是在傳遞給其他函式作為回調時。
* *簡潔性*：在簡單的場景中，不需要為函式命名，可以簡化代碼。


==== 3. 立即執行函式表達式（IIFE）

匿名函式經常與立即執行函式表達式一起使用，這是一種在定義函式後立即執行它的方式。

==== 定義和使用：

[source,javascript]
----
(function() {
console.log("這是一個立即執行的匿名函式");
})();  // 輸出：這是一個立即執行的匿名函式
----


=== 總結

* *具名函式*：有助於提高代碼的可讀性，適合重複使用的情況。
* *匿名函式*：靈活且簡潔，適合一次性使用或作為回調函式。

== Automatic Semicolon Insertion, ASI
== Introduction

自動插入分號 (Automatic Semicolon Insertion, ASI) 是 JavaScript
的一個特性，允許在省略分號時自動補全。這在大部分情況下能正常運作，但也有可能導致意想不到的行為。


=== 自動插入分號 (ASI) 基本概念


=== 自動插入分號機制

在某些情況下，當 JavaScript
解析器遇到一行無分號的結尾時，它會嘗試自動插入分號來修正代碼。


[source,javascript]
----
// 沒有分號，JavaScript 自動插入
let a = 5
let b = 10
console.log(a + b)
----

這裡，雖然每行末尾沒有分號，JavaScript 解析器會自動插入分號。

=== 自動插入分號的規則

JavaScript 會在以下情況下自動插入分號：

* 當語句以換行符結束時
* 在關鍵字 `break`, `return`,`throw` 後跟著換行符時



[source,javascript]
----
return
5 + 10
----


這段代碼會被解析為 `return;` 和
`5 + 10;`，而不是 `return 5 + 10;`。


=== 常見例外

然而，自動插入分號機制並非總是有效，且有一些情況下會導致錯誤：

[source,javascript]
----
const foo = () => {}
[1, 2].forEach(console.log)
----


這段代碼會產生錯誤，因為 JavaScript
會將這兩行解讀為兩個分離的語句，而不是一個函式後接一個陣列。

=== ASI 的影響與最佳實踐


為了避免 ASI
帶來的潛在問題，開發者通常建議始終顯式地在語句末尾添加分號。這樣可以減少錯誤並提高代碼的可讀性。



== 原始型別/物件型別


=== 1. 原始型別（Primitive Types）

原始型別是最基本的數據類型，它們是不可變的（immutable），且直接存儲其值。JavaScript
中的原始型別共有 7 種：

* *string*：表示字串，例如 "Hello"
* *number*：表示數字，包括整數和浮點數，例如 42、3.14
* *bigint*：表示任意精度的整數，例如 9007199254740991n
* *boolean*：表示布林值 true 或 false
* *undefined*：當變數已聲明但尚未賦值時，其值是 undefined
* *null*：表示空值，通常用來表示“無”的狀態
* *symbol*：用來創建唯一的標識符，例如 Symbol("unique")

==== 特點：


* 不可變性：原始型別的值不能被修改，任何對其值的操作都會生成新值，而不是修改原值。
* 按值傳遞：當將原始型別賦值或傳遞給變數時，是以值的方式傳遞，也就是說它們之間互相獨立。

==== 範例：

[source,javascript]
----
let numA = 10;
let numB = numA;  // numB 是 numA 的複製
numA = 20;
console.log(numB);  // 輸出 10
----

在這裡，numA 的修改不會影響 numB，因為它們各自存儲了自己的值。


=== 2. *物件型別（Object Types）*

物件型別是由鍵值對組成的可變集合。所有非原始型別的數據都是物件型別，包括陣列、函數、日期等。


==== 常見的物件型別：

* *物件（Object）*：包含鍵值對，例如
`{ name: "John", age: 30 }`
* *陣列（Array）*：一種特殊的物件，用來存儲有序的數據列表，例如
`[1, 2, 3]`
* *函數（Function）*：也是物件類型，可以作為一等公民進行操作，例如
`function add(a, b) { return a + b; }`
* *日期（Date）*：表示日期和時間的物件類型，例如
`new Date()`
* *正則表達式（RegExp）*：表示正則表達式的物件類型，例如
`/abc/`


補充說明：

* *稀疏陣列（Sparse Array）*：指陣列中存在空洞或未定義的元素。

[source,javascript]
----
let sparseArr = [1, , 3];
console.log(sparseArr.length);  // 3
console.log(sparseArr[1]);  // undefined
----

* *鍵值的強制轉型*：陣列的索引實際上是物件的鍵，會自動轉型為字串。

[source,javascript]
----
let arr1 = [];
arr1[1] = 'a';
arr1['1'] = 'b';
console.log(arr1[1]);  // 'b'
----

* *字串的類陣列處理與比較不同資料型態的儲存方式*：字串作為類陣列，字串與數字進行比較時會自動進行類型轉換。

[source,javascript]
----
console.log('5' == 5);  // true，因為 '5' 被轉型為數字 5
console.log('5' === 5);  // false，因為這裡類型不相同
----

* *非常大與非常小的數字*：JavaScript 中使用 BigInt 處理非常大的整數，浮點數則需注意運算精度問題。

[source,javascript]
----
const a = 1e20; // 1e20 的數值
const b = a * 100; // b 為 1e+22
const c = a / 0.001; // c 為 1e+23

console.log(a); // 100000000000000000000
console.log(b); // 1e+22
console.log(c); // 1e+23

console.log(a.toExponential()); // "1e+20"
----



==== 特點：

* 可變性：物件型別的值是可變的，可以在原來的基礎上修改或擴展。
* 按引用傳遞：物件型別是按引用傳遞的，這意味著如果多個變數引用同一個物件，對其中一個變數所作的改變會影響到所有引用該物件的變數。


==== 範例：

[source,javascript]
----
  let objA = { name: "Alice" };
  let objB = objA;  // objB 引用同一個物件
  objA.name = "Bob";
  console.log(objB.name);  // 輸出 "Bob"
----



在這裡，`objA` 和 `objB` 都引用了同一個物件，因此對 `objA` 所做的修改會影響 `objB`。


=== 3. 原始型別與物件型別的差異

[cols="1,1,1", options="header"]
|===
| 特性 | 原始型別（Primitive Types） | 物件型別（Object Types）

| *可變性*
| 不可變，每次操作都返回新值
| 可變，可以直接修改屬性和方法

| *比較方式*
| 比較值本身（按值比較）
| 比較引用（按引用比較）

| *存儲方式*
| 直接存儲其值
| 存儲的是對象的引用地址（指向內存位置）

| *傳遞方式*
| 按值傳遞，每個變數互相獨立
| 按引用傳遞，變數間共享對象

| *類型數量*
| 7 種：`string`, `number`, `boolean`, `bigint`, `undefined`, `null`, `symbol`
| 無限數量，包含 `Object`、`Array`、`Function` 等
|===


=== 小結：

* *原始型別*：是簡單且不可變的數據類型，適合表示基礎數據。
* *物件型別*：靈活且可變，適合存儲和操作複雜的數據結構。


這兩種型別的理解對於正確處理 JavaScript
中的數據結構至關重要，尤其是在變數賦值和比較時。


== 顯性轉換/隱性轉換

在 JavaScript 中，*顯性轉換（Explicit Conversion）*和*隱性轉換（Implicit Conversion）*指的是將一種資料類型轉換為另一種的過程。這兩種轉換的區別在於轉換是否是由開發者主動進行，或者是由 JavaScript 引擎自動進行。

=== 顯性轉換（Explicit Conversion）

顯性轉換是指開發者*主動*使用內建方法或運算符來將一種類型轉換為另一種類型。這是一個清晰、可控的過程，開發者確切地知道何時進行轉換。

==== 常見的顯性轉換方法

===== 轉換為數字

* 使用 `Number()` 函數或 `parseInt()`、`parseFloat()` 方法將其他類型的數據轉換為數字。

[source,javascript]
----
console.log(Number('123'));            // 123
console.log(Number('-123.239'));       // -123.239
console.log(Number('123abc'));         // NaN
console.log(Number(undefined));        // NaN
console.log(Number(true));             // 1
console.log(Number(false));            // 0
console.log(Number(null));             // 0
console.log(Number('1e+5'));           // 100000
console.log(Number('  '));             // 0 (whitespace is trimmed)
console.log(Number('Infinity'));       // Infinity
console.log(Number('0xF'));            // 15 (Hexadecimal conversion)
----

`Number()` 的目標是判斷值是否像數字，如果像數字則轉換成功，否則為 NaN。例如 true, false, null 分別為 1, 0, 0。

邊界情況：undefined 會轉換為 NaN，空字串或空白字符會轉換為 0，十六進制字串會轉換為對應的數值。

===== `parseInt()` 和 `parseFloat()`

* `parseInt()` 會將值轉換成整數，而 `parseFloat()` 保留小數。

[source,javascript]
----
console.log(parseInt('123.2'));        // 123
console.log(parseInt('123abc'));       // 123
console.log(parseInt('a'));            // NaN
console.log(parseFloat('123.239abc')); // 123.239
console.log(parseInt('100px'));        // 100
console.log(parseInt('10', 16));       // 16 (interprets as hexadecimal)
----

💡 `parseInt()` 從第一位開始判斷，遇到非數字位就停止；而 `parseFloat()` 會保留小數。

邊界情況：可以傳入進制參數給 `parseInt()`，非數字字符會導致停止轉換。

===== 轉換為字串

* 使用 `String()` 函數或 `toString()` 方法將其他類型的數據轉換為字串。

[source,javascript]
----
console.log(String(-123));             // "-123"
console.log(String(true));             // "true"
console.log((123).toString());         // "123"
console.log(String([1, 2, 3]));        // "1,2,3"
console.log(String({}));               // "[object Object]"
console.log(String(undefined));        // "undefined"
console.log(String(null));             // "null"
----

`undefined` 和 `null` 不能使用 `toString()`。物件會返回 "[object Object]"，除非定義了自訂的 `toString()` 方法。

===== 轉換為布林值

* 使用 `Boolean()` 函數來將其他類型轉換為布林值。

[source,javascript]
----
console.log(Boolean(0));               // false
console.log(Boolean(''));              // false
console.log(Boolean('hello'));         // true
console.log(Boolean(undefined));       // false
console.log(Boolean([]));              // true
console.log(Boolean({}));              // true
----

除了 `0`, `""`, `undefined`, `null`, `NaN`，其餘值皆為 `true`。

邊界情況：空陣列和空物件也是 `true`。

=== 隱性轉換（Implicit Conversion）

隱性轉換是指 JavaScript 在進行某些運算或操作時*自動*將一種資料類型轉換為另一種，這通常發生在運算符處理不同類型的數據時。

==== 常見的隱性轉換情況

* *字串與其他類型的相加*：當字串與數字或其他類型相加時，JavaScript 會將其他類型轉換為字串進行拼接。

[source,javascript]
----
let result = "The answer is " + 42;   // "The answer is 42"
let result2 = [1, 2, 3] + "";          // "1,2,3"
console.log([] + {});                  // "[object Object]"
console.log({} + []);                  // 0
----

* *數字運算中的布林值*：布林值會被轉換為數字：`true` 轉換為 1，`false` 轉換為 0。

[source,javascript]
----
let sum = true + 2;                    // 3
let difference = false - 1;            // -1
----

* *isNaN() 函數*：`isNaN()` 用來判斷值是否為「NaN」。它會隱式調用 `Number()` 來進行判斷。

[source,javascript]
----
console.log(isNaN("abc"));            // true
console.log(isNaN(undefined));         // true
console.log(isNaN("123"));            // false (implicitly converts to number)
----

* *加法運算符（+）*：當 + 處理字串和其他類型時，會將其他類型轉換為字串進行拼接。

[source,javascript]
----
console.log('10' + 1);                 // "101"
console.log('10' - 1);                 // 9
----

* *乘法與除法運算*：當使用乘法或除法運算符與字串進行運算時，JavaScript 會嘗試將字串轉換為數字。無法轉換的字串會返回 NaN。

[source,javascript]
----
console.log('6' * 2);                  // 12 (string '6' is converted to number 6)
console.log('10' / 2);                 // 5 (string '10' is converted to number 10)
console.log('abc' * 2);                // NaN (string 'abc' cannot be converted)
console.log('5.5' * 2);                // 11 (string '5.5' is converted to 5.5)
----

* *物件隱式轉換*：當物件與原始類型進行運算時，JavaScript 會調用物件的 `toString()` 或 `valueOf()` 方法進行隱式轉換。

[source,javascript]
----
let obj = {
  valueOf() { return 10; }
};
console.log(obj + 1);                  // 11
----

=== 隱性轉換的常見問題

隱性轉換有時會導致意外的行為，特別是在比較和運算時。例如：

* + 和 - 的不同處理：`+` 用於字串拼接，而 `-` 會進行數字轉換。

[source,javascript]
----
let result = "10" + 1;                // "101"
let result2 = "10" - 1;               // 9
----

* *BigInt 和 Symbol*：BigInt 不能與其他原始類型混合運算，必須顯性轉換。Symbol 也無法與其他類型進行運算。

[source,javascript]
----
console.log(1 + 1n);                  // Uncaught TypeError: Cannot mix BigInt and other types
console.log(1 + Symbol("1"));        // Uncaught TypeError: Cannot convert a Symbol value to a number
----

* *NaN 的處理*：任何與 NaN 進行的運算都會返回 NaN。

[source,javascript]
----
console.log(NaN + 5);                 // NaN
console.log("abc" - 1);              // NaN
----
=== 顯性轉換 vs 隱性轉換

[cols="1,1,1", options="header"]
|===
| 特點 | 顯性轉換 | 隱性轉換

| 誰發起轉換
| 開發者明確進行
| JavaScript 引擎自動進行

| 轉換的控制
| 完全控制
| 無法控制，取決於上下文

| 轉換方式
| 使用明確的方法如 `Number()`, `String()`
| 發生於運算符、比較、條件運算時

| 示例
| `Number('123')` 明確將字串轉數字
| `'123' - 1` 自動將字串轉換為數字

| 潛在問題
| 可預期，易於調試
| 隱式轉換有時會導致意外的結果，如字串拼接或布林轉換

| 性能
| 轉換有具體步驟，略微增加計算負擔
| 依賴 JavaScript 引擎處理，通常較快但難以預料
|===


== 型別比較

在 JavaScript 中，型別比較（type comparison）是經常遇到的問題，因為
JavaScript
是動態型別語言，因此變數的型別可以在運行時期改變。JavaScript
提供了兩種主要的比較運算符：


=== 1. 寬鬆比較（Loose Equality）：==

使用 == 進行比較時，JavaScript
會嘗試在比較前進行類型轉換，這意味著即使變數的類型不同，也可能返回
true。


[source,javascript]
----
console.log(5 == '5');  // true
console.log(0 == false); // true
console.log(null == undefined); // true
----


==== 規則：

* JavaScript 會自動將不同類型的數據轉換為相同類型再進行比較。
* 字符串和數字會轉換為數字比較。
* null 和 undefined 被視為相等。
* false 會被轉換為 0，true 會被轉換為 1。


問題：

* 由於自動型別轉換，這種比較有時會導致意想不到的結果。因此，通常不推薦使用。


=== 2. 嚴格比較（Strict Equality）：===

使用 === 進行比較時，JavaScript
會不進行類型轉換，這意味著變數的類型和值必須完全相同才能返回 true。


[source,javascript]
----
console.log(5 === '5');  // false
console.log(0 === false); // false
console.log(null === undefined); // false
----


==== 規則：

* 如果兩個值的類型不同，直接返回 false。
* 必須在類型和值都相等的情況下，才會返回 true。


==== 優點：

* 避免自動型別轉換的混淆。
* 更加明確和可預測，適合大多數比較情境。


=== 3. 其他比較方法

Object.is() 用於比較兩個值是否相同，與 ===
大致相同，但處理一些特殊值（如 NaN 和 -0）的方式不同。


[source,javascript]
----
console.log(Object.is(NaN, NaN));  // true
console.log(NaN === NaN);  // false
console.log(Object.is(+0, -0)); // false

----


=== 4. 使用場景

=== 嚴格比較：在大多數情況下，應該使用 ===，因為它更加安全和清晰。


== 寬鬆比較：當你確實需要進行不同類型之間的比較，並且希望 JavaScript
自動進行類型轉換時，才考慮使用。


=== 常見陷阱

null 和 undefined 在 == 下相等，但在 === 下不相等。 +
NaN 與任何值都不相等，包括它自己，所以比較 NaN 值時應使用 isNaN() 或
Object.is()。


=== 總結


使用 === 進行嚴格比較可以避免 JavaScript
自動進行型別轉換時帶來的潛在錯誤。 +
  == 可以依照業務需求特性使用。

